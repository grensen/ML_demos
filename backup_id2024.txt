using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

class TheWindow : Window
{
    // colors
    readonly SolidColorBrush font = new(Color.FromRgb(212, 212, 212));
    readonly SolidColorBrush brFont2 = new(Color.FromRgb(9, 6, 0));
    // support 
    readonly CultureInfo ci = CultureInfo.GetCultureInfo("en-us");

    /*
     Comic Neue
    Chalkduster
    Marker Felt
    Jokerman
    Kristen ITC
    Papyrus
    Brush Script MT
    Forte
    Segoe Print
    Viner Hand ITC
     */

    /*
    Arial
    Times New Roman
    Calibri
    Segoe UI
    Verdana
    Tahoma
    Consolas
    Comic Sans MS
    Courier New
    Palatino Linotype 
    */

    /*
    Bodoni MT Poster Compressed
    Curlz MT
    Edwardian Script ITC
    Gigi
    Monotype Corsiva
    */
    readonly Typeface tf = new("Arial"); // new("TimesNewRoman");// new("Segoe Print"); // "Arial" new("TimesNewRoman");

    // layout
    Canvas canMenu = new(), canGlobal = new(), canVisual = new(), canCurrent = new(), canRuler = new(), canConsole = new();

    // Integer Types
    int ys = 145;
    int xs = 15;
    int gap = 3;
    int lastPoint = 0;
    int lastStateG = -1;
    int height = 0;
    int features = 0;
    int modelSize = 1000;
    int layerSize = 2;
    int testSize = 100;
    int ColorSize = 5;
    int penSize = 10;
    int boost = 1;
    int style = 0;
    int featureMode = -1;
    int lineStyles = 0;
    int labelStyleID = 1; // test accuracy
    int dataLength = 0;
    int numberOfActiveNets = 0;
    int currentButton = 0;
    int currentTickCount = 0;
    int lastXY = -1;

    // Float Types
    float fs = 0.0f;
    float testAccMean = 0;
    float countThickness = 0.5f;
    float highscore = 0;

    // Boolean Types
    bool showGrid = true, showValues = true, 
        showMeans = false;
    bool stackdata = true;
    bool click = false, datasetChange = false,featureEngineering = false;
    // Arrays and Collections
    bool[] featureState = [], isOut = [];
    float[] minVal = [], maxVal = [], trainData = [];
    string[] featureNames = [];
    readonly Brush[] br = new Brush[3];
    Brush[] clrarr = [];
    RunningStat[] statHi = null, statLo = [];

    // Objects
    AutoData data; // = new(@"C:\ml_data\", AutoData.DatasetType.FashionMNIST); // get data
    Control cntrl;
    // Collections
    List<Rules> rules = [];
    Ranges[] ranges;

    // Other
    readonly Stopwatch stopwatchGlobal = Stopwatch.StartNew();
    string globalStr = "";

    readonly string[] styleNames = ["Feat to feat", "Label to feat", "Lines", "Label to lines", "Feat to lines", "Distributions"];
    readonly string[] boostNames = ["Default", "Bounds", "Gradations", "Tune", "Invert"];
   
    string[] featureNamesNeuralNetwork = [
        "Training acc", "Test acc", "Training time", "Test time",
        "Epochs", "Training size", "Batchsize", "Learning rate",
        "Momentum", "EpochLrDecrease", "Backprop prob", "Seed"//, "Layers"//, "Weights" 
    ];
    // new menu
    readonly string[] newMenuName = [
        "Train", "MNIST", "Test acc", "Stack",
        "Update", "Spread" , "Range", "Take",
        "Test size", "Neural nets",
        "Layers", "Colors" ,
        "Pen size",
        "Boost",
        "Style" ,
        "Accent",//"Gradient", "Confusion" , 
        "Grid", "Info", "HiLo μ", "ID",
       "Gradient", "Confusion" ,  "last" , "Weights", "Structured" , "Dataset", "Delta"
    ];

    readonly int[] menuStructure = [
        4, // train, test, add, edit
        4, // reset, abort, show, back
        3, // lr, mom
        3, // Confusion , Bias, Infinity, Reweight 
        2, // Weights, Structured, Dataset, Delta
        3, // one, two, three
    ];

    readonly int[] stateMenu = [
        0, 0, 0, 0, 0,
        0, 0, 0, 1, 1,
        1, 1, 1, 1, 1,
        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 
        ];

    enum MenuElements
    {
        ButtonClick,
        Slider,
        ButtonState,
        Slider2Way,
        ButtonProgressBar,
        DropDownList, TextBox
    }

    [STAThread]
    static void Main(){ new Application().Run(new TheWindow()); }
   // private 

    private TheWindow() // constructor - set window
    {
        Content = canGlobal;

        Title = "tempcode version !!!!!!!!!! Parallel Coordinates on NN Predictions";
        Background = RGB(0, 0, 0);
        Width = 1500;
        Height = 750;

        MouseWheel += Mouse_Wheel;
        MouseDown += Mouse_Down;
        MouseMove += Mouse_Move;
        MouseUp += Mouse_Up;
        SizeChanged += Window_SizeChanged;

        canGlobal.Children.Add(canMenu);
        canGlobal.Children.Add(canVisual);
        canGlobal.Children.Add(canRuler);
        canGlobal.Children.Add(canCurrent);
        canGlobal.Children.Add(canConsole);

        // get data
        data = new(@"C:\ID_2024\", AutoData.DatasetType.MNIST);

        InitRanges(layerSize);

        cntrl.ruleLabel = 1;
        NeuralNetPredictionData();

        br[0] = RGB(60, 80, 225); // blue
        br[1] = RGB(239, 182, 0); // gold
        br[2] = RGB(96, 96, 96); // red       

        clrarr = InitColors(ColorSize);

        return; // continue in Window_SizeChanged()...
    } // TheWindow end

    void InitRanges(int layers)

    {        // init prediction ranges etc
        List<string> featureNamesList = new List<string>(featureNamesNeuralNetwork.Take(12));
        for (int i = 0; i < layers; i++)
            featureNamesList.Add("Hidden Units" + (i + 1).ToString());

        featureNamesNeuralNetwork = featureNamesList.ToArray();

        featureNames = featureNamesNeuralNetwork;
        features = featureNames.Length;

        if (ranges != null) // running
        {
            var old = ranges;
            ranges = new Ranges[features];

            for (int i = 0; i < 8; i++)
                ranges[i].minMax = old[i].minMax;
            //  ranges[8].minMax = (1, layers); // layers
            // Array.Resize(ref ranges, 9 + layers);
            for (int i = 0; i < layers; i++)
                ranges[8 + i].minMax = (20, 100); // hidden neurons
        }
        else // init
        {
            ranges = new Ranges[features];
            ranges[0].minMax = (1, 5); // epochs
            ranges[1].minMax = (100, 500); // trainsize
            ranges[2].minMax = (10, 200); // batchsize
            ranges[3].minMax = (0.0f, 1.00f); // lr
            ranges[4].minMax = (0.0f, 1.0f); // mom
            ranges[5].minMax = (0.0f, 1.0f); // lrdecayfactor
            ranges[6].minMax = (0.0f, 1.0f); // bpprob
            ranges[7].minMax = (0, 100000); // seed
         //   ranges[8].minMax = (1, layers); // layers

            // Array.Resize(ref ranges, 9 + layers);
            for (int i = 0; i < layers; i++)
                ranges[8 + i].minMax = (20, 50); // hidden neurons
        }
    }
    float menuWidth = 300;
    void MenuVisual(ref DrawingContext dc, int lastSt = -1, float progress = -1)
    {
      
        double y = 15;
        int len = false ? 5 : menuStructure.Length;
        for (int j = 0, c = 0; j < len; j++, y += 16 + 3)
        {
            float buttonWidth = (menuWidth + (5 - (menuStructure[j] - 1)) * gap) / menuStructure[j];
            double x = 15;
            for (int i = 0; i < menuStructure[j]; i++, c++, x += buttonWidth + gap)
            {
                //  Brushes stateColor = new SolidBrush(Color.Red);
                Brush stateColor = lastSt == c ? Brushes.CornflowerBlue : Brushes.RoyalBlue;
                Brush stateColor2 = lastSt == c ? Brushes.DarkGray : Brushes.DimGray;

                if (c == 0)
                {
                    if (progress == -1) progress = 1;
                    drawMenu(ref dc, x, y, buttonWidth, 16, "" + c.ToString() + " " + newMenuName[c] + $" ({dataLength})", progress, 1, 11, brFont2);
                }
                else if (c == 8) // 
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + testSize.ToString("F0"), testSize, 10000, 11, brFont2);

                else if (c == 9) // models
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + modelSize.ToString("F0"), modelSize, 1000, 11, brFont2);
                else if (c == 10) // lr
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + layerSize.ToString("F0"), layerSize, 5, 11, brFont2);
                else if (c == 11) // ColorSize
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + ColorSize.ToString("F0"), ColorSize, 50, 11, brFont2);
                else if (c == 12) // penSize 
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + penSize.ToString("F0"), penSize, 50, 11, brFont2);
                else if (c == 13) // boost
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + boost.ToString("F0"), boost, 50, 11, brFont2);
                else if (c == 14) // style
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c], style, 5, 11, brFont2);
                else if (c == 15) // accent
                    drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c], lineStyles, (boostNames.Length - 1), 11, brFont2);
                /*  
                  else if (c == 12) // noise
                      drawMenu(ref dc, x, y, buttonWidth, 16, newMenuName[c] + " " + noise.ToString("F2"), noise, 1, 10, brFont2);
                  else if (c == 13) // start end two way slider
                  {
                      // background
                      float l = buttonWidth * (start / 60000.0f), r = buttonWidth * (end / 60000.0f);
                      dc.DrawRectangle(stateColor2, null, new Rect(x, y, buttonWidth, 16)); // element background
                      dc.DrawRectangle(stateColor, null, new Rect(x + l, y, r - l, 16)); // element value
                      dc.DrawRectangle(Brushes.Black, null, new Rect(x + l + (r - l) / 2, y, 1, 16)); // control line

                      dc.DrawText(new FormattedText(//newMenuName[c] + 
                          newMenuName[c] + "\n" + start.ToString(), ci, FlowDirection.LeftToRight, tf, 7, brFont2, VisualTreeHelper.GetDpi(this).PixelsPerDip),
                          new Point(x + 1, y - 0));
                      dc.DrawText(new FormattedText(//newMenuName[c] + 
                          "end\n" + end.ToString(), ci, FlowDirection.LeftToRight, tf, 7, brFont2, VisualTreeHelper.GetDpi(this).PixelsPerDip),
                          new Point(x + 1 + buttonWidth * 0.75, y - 0));
                  }
                  */
                else // button
                {
                    dc.DrawRectangle((stateMenu[c] == 0 ? stateColor : stateColor2), new Pen(), new Rect(x, y, buttonWidth, 16));
                    dc.DrawText(new FormattedText(c.ToString() + " " + newMenuName[c], ci, FlowDirection.LeftToRight, tf, 11, brFont2, VisualTreeHelper.GetDpi(this).PixelsPerDip),
                        new Point(x + 2, y + 2));
                }

                void drawMenu(ref DrawingContext dc, double x, double y, double width, double height, string str, double val, double max, int size, Brush fc)
                {
                    dc.DrawRectangle(stateColor2, new Pen(), new Rect(x, y, width, height));
                    dc.DrawRectangle(stateColor, new Pen(), new Rect(x, y, width * (val / max), height));
                    dc.DrawText(new FormattedText(str, ci, FlowDirection.LeftToRight, tf, size, fc, VisualTreeHelper.GetDpi(this).PixelsPerDip), new Point(x + 2, y + 2));
                }
            }
        } // visual end
    }

    void Menu(double gpx, double gpy, bool down, bool move, bool up)
    {
        int currentXY = (int)(gpx * gpy);
        if (currentXY == lastXY && !up) return;
        lastXY = currentXY;

        /*  DrawingContext dc2 = ContextHelpMod(!true, ref canConsole);
          // draw console 
          // upper new
          //  DrawConsole(240, 70);
          void DrawConsole(int x, int y)
          {
              Rect(ref dc2, font, x + 0, y, 530, 35);
              Rect(ref dc2, RGB(0, 0, 0), x + 0 + 1, y + 1, 530 - 2, 35 - 2);
              Text(ref dc2, $"currentTickCount:{++currentTickCount,3}   gpx:{gpx,3}    gpy:{gpy,3}    down:{down}  move:{move}  up:{up} " +
                  $" currentButton:{currentButton} lastStateG:{lastStateG}", 11, font, x + 0 + 5, y + 4);
              Text(ref dc2, $"str: " + globalStr, 11, font, x + 0 + 5, y + 19);
          }
          dc2.Close();*/     
        if(!down) Thread.Sleep(down ? 16 : 32); // cool down mouse movement
        int len = false ? 5 : menuStructure.Length;
        currentButton = -1;
        {
            double y = 15;
            for (int j = 0, c = 0; j < len; j++, y += 16 + 3)
            {
                float x = 15, buttonWidth = (menuWidth + (5 - (menuStructure[j] - 1)) * gap) / menuStructure[j];
                for (int i = 0; i < menuStructure[j]; i++, c++, x += buttonWidth + gap)
                    if (gpx <= x + buttonWidth && gpx >= x && gpy > y && gpy < y + 16)
                    {
                        currentButton = c; break;
                    }
            }
        }
        if (down && lastStateG != currentButton && lastStateG != -1) return;
        // 
        if (!down && !up)
        {
            DrawMenuVisual(currentButton); return;
        }

        if (!down && lastStateG == currentButton) return;

        {
            double y = 15;
            for (int j = 0, c = 0; j < len; j++, y += 16 + 3)
            {
                float x = 15, buttonWidth = (menuWidth + (5 - (menuStructure[j] - 1)) * gap) / menuStructure[j];
                for (int i = 0; i < menuStructure[j]; i++, c++, x += buttonWidth + gap)
                    if (gpx <= x + buttonWidth && gpx >= x && gpy > y && gpy < y + 16)
                    {
                        // if (!up) if (!down && currentButton == c) return;
                        // currentButton = c; 
                        // if (!pressed && lastStateG == c) return;
                        // if (lastStateG != c && lastStateG != -1) return;
                        //   if (!down && lastStateG != c) { DrawMenuVisual(c); return; } // button hover 
                        string str = "";

                        float position = (float)(gpx - x) * (100.0f / buttonWidth) / 100.0f;

                        if (c == 0)
                        {
                            stateMenu[c] = stateMenu[c] == 0 ? 1 : 0;
                            Stopwatch stopwatchLocal = Stopwatch.StartNew();
                            NeuralNetPredictionData();
                            var time = (float)(stopwatchLocal.Elapsed.TotalMilliseconds / 1000.0);
                            DrawParallelCoordinates(newMenuName[c] + $"Elapsed = {time:F4} ");
                        }
                        else if (c == 1)
                        {
                            datasetChange = !datasetChange;
                            newMenuName[1] = datasetChange ? "Fashion" : "MNIST";
                            data = new(@"C:\ml_data\", datasetChange ? AutoData.DatasetType.FashionMNIST : AutoData.DatasetType.MNIST); // get data
                            testAccMean = 0;
                        }
                        else if (c == 2) // 
                        {
                            if (++labelStyleID >= features) labelStyleID = 0;
                            newMenuName[2] = featureNames[labelStyleID];
                            DrawParallelCoordinates("new_menu_training");
                        }
                        else if (c == 3) // stack or new
                        {
                            stackdata = !stackdata;
                            newMenuName[3] = stackdata ? "Stack" : "New";
                            DrawParallelCoordinates("new_menu_training");
                        }
                        else if (c == 4) // reset
                        {
                            canRuler.Children.Clear();
                            rules = [];
                            Stopwatch stopwatchLocal = Stopwatch.StartNew();
                            stackdata = false;
                            NeuralNetPredictionData();
                            stackdata = true;
                            var time = (float)(stopwatchLocal.Elapsed.TotalMilliseconds / 1000.0);
                            DrawParallelCoordinates(newMenuName[c] + $"Elapsed = {time:F4} ");
                        }
                        else if (c == 5) // derange
                        {
                            /*
                                    minVal = new float[features];
                                    maxVal = new float[features];
                                    featureState = new bool[features];
                                    for (int featureIndex = 0; featureIndex < features; featureIndex++)
                                    {
                                        float currentMin = float.MaxValue, currentMax = float.MinValue;
                                        for (int dataIndex = 0; dataIndex < dataLength; dataIndex++)
                                        {
                                            if (!isOut[dataIndex])
                                            {
                                                var value = trainData[featureIndex + features * dataIndex];
                                                if (value < currentMin) currentMin = value;
                                                if (value > currentMax) currentMax = value;
                                            }

                                        }

                                        featureState[featureIndex] = (currentMin != currentMax) ? true : false;

                                        minVal[featureIndex] = currentMin;
                                        maxVal[featureIndex] = currentMax;
                                    }
                             */

                            for (int ii = 4; ii < minVal.Length - (layerSize - layerSize + 0); ii++)
                            {
                                if (ii == 12) continue;
                                maxVal[ii] *= 1.05f;
                                minVal[ii] *= 0.95f;
                                ranges[ii - 4].minMax = (minVal[ii], maxVal[ii]);
                            }
                            DrawParallelCoordinates("derange");
                            // todo
                        }
                        else if (c == 6) // "Set Range"
                        {
                            SetMaxMin();
                            DrawParallelCoordinates("max min data");
                        }
                        else if (c == 7) // ranger styles
                        {
                            if (++cntrl.ruleLabel > 2) cntrl.ruleLabel = 1;
                            newMenuName[7] = cntrl.ruleLabel == 1 ? "Take" : "Hide";

                            canMenu.Children.Clear();
                            DrawingContext dc = ContextHelpMod(false, ref canMenu);
                            MenuVisual(ref dc);
                            dc.Close();
                            DrawParallelCoordinates(7 + " ranger styles" + newMenuName[7]);
                        }
                        else if (c == 8)
                        {
                            str = c.ToString() + " " + (testSize = (int)(position * 9900.0f + 100)).ToString() + "\n";
                        }
                        else if (c == 9) // number of neural networks
                        {
                            str = c.ToString() + " " + (modelSize = (int)(position * 999.0f + 1)).ToString("F0") + "\n";
                        }
                        else if (c == 10) // layers
                        {
                            int srcLayers = layerSize;
                            str = c.ToString() + " " + (layerSize = (int)MathF.Round(position * 4.0f + 1)).ToString("F0") + "\n";// lr
                   
                            if (srcLayers != layerSize)
                            {
                                InitRanges(layerSize);                   
                                stackdata = false;
                                int csize = modelSize;
                                modelSize = 0;
                                NeuralNetPredictionData();
                                modelSize = csize;
                                stackdata = true;

                                DrawParallelCoordinates(c + " layerSize" + newMenuName[c]);
                            }            
                        }
                        else if (c == 11) // color size
                        {
                            int srcColorSize = ColorSize;
                            str = c.ToString() + " " + (ColorSize = (int)MathF.Round(position * 48.0f + 2)).ToString() + "\n";
                            if (srcColorSize != ColorSize)
                            {
                                clrarr = InitColors(ColorSize);
                                newMenuName[c] = "ColorSize ";
                                DrawParallelCoordinates(c + " ColorSize" + newMenuName[c]);
                            }
                        }
                        else if (c == 12) // pen size
                        {
                            int srcPen = penSize;
                            str = c.ToString() + " " + (penSize = (int)MathF.Round(position * 49.0f + 1)).ToString() + "\n";
                            if (srcPen != penSize)
                            {
                                newMenuName[c] = "Pen ";
                                DrawParallelCoordinates(c + " penSize" + newMenuName[c]);
                            }
                        }
                        else if (c == 13) // boost: def, bound, grad...
                        {
                            int old = boost;
                            str = c.ToString() + " " + (boost = (int)MathF.Round(position * 49.0f + 1)).ToString() + "\n";
                            if (old != boost)
                            {
                                // newMenuName[c] = boostNames[lineStyles];

                                DrawParallelCoordinates(c + " boost" + newMenuName[c]);
                            }
                        }
                        else if (c == 14) // style
                        {
                            int srcStyle = style;
                            str = c.ToString() + " " + (style = (int)MathF.Round(position * 5.0f)).ToString() + "\n";
                            if (srcStyle != style)
                            {
                                newMenuName[c] = styleNames[style];
                                DrawParallelCoordinates(str + " Style " + newMenuName[c] + " " + style);
                            }

                        }
                        else if (c == 15) // accent lineStyles
                        {
                            int srclineStyles = lineStyles;
                            str = c.ToString() + " " + (lineStyles = (int)MathF.Round(position * (boostNames.Length - 1))).ToString() + "\n";
                            if (srclineStyles != lineStyles)
                            {
                                newMenuName[c] = boostNames[lineStyles];

                                DrawParallelCoordinates(c + " boost" + newMenuName[c]);
                            }
                        }

                        else if (c == 16) // grid on off
                        {
                            stateMenu[c] = showGrid ? 1 : 0;
                            showGrid = !showGrid;
                            // newMenuName[c] = showGrid ? "showGrid off" : "showGrid on";
                            DrawParallelCoordinates(newMenuName[c]);
                        }
                        else if (c == 17) // showValues on off
                        {
                            stateMenu[c] = showValues ? 1 : 0;
                            showValues = !showValues;
                            DrawParallelCoordinates(newMenuName[c]);
                        }
                        else if (c == 18) // means topHiLo on off
                        {
                            stateMenu[c] = showMeans ? 1 : 0;
                            showMeans = !showMeans;
                            DrawParallelCoordinates(newMenuName[c]);
                        }
                        /*
                        if (c == 13) // start - end data two way slider
                        {
                            int currentPosition = (int)(position * 59999) + 1;
                            float l = buttonWidth * (start / 60000.0f), r = buttonWidth * (end / 60000.0f);

                            if (buttonState == 0) // button click down
                            {
                                if (position <= (l + (r - l) / 2) / 100) // start
                                {
                                    start = currentPosition; stateMenu[c] = 3; // start left clicked                               
                                }
                                if (position > (l + (r - l) / 2) / 100)
                                {
                                    end = currentPosition; stateMenu[c] = 4; // end right clicked                                
                                }
                            }
                            else
                            {
                                if (stateMenu[c] == 3) // button is clicked, move start slider
                                    start = end >= currentPosition ? currentPosition : end;
                                if (stateMenu[c] == 4) // button is clicked, move end slider
                                    end = currentPosition >= start ? currentPosition : start;
                            }
                        } // start - end data                       
                        */

                        if (up)
                        {
                            DrawingContext dc = ContextHelpMod(false, ref canMenu);
                            MenuVisual(ref dc, c);
                            dc.Close();
                            Application.Current.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Render, new Action(delegate { }));
                            return;
                        }

                        lastStateG = c;

                        if (str == "") // active element
                        {
                            globalStr = "Click active element " + c.ToString() + " " + newMenuName[c] + " ";
                            DrawingContext dc = ContextHelpMod(false, ref canMenu);
                            MenuVisual(ref dc);
                            dc.Close();
                            if (c > 7) stateMenu[c] = stateMenu[c] == 0 ? 1 : 0;
                            // ggExec("Click active element " + c.ToString() + " " + newMenuName[c] + "\n", false, target);
                            return;
                        }
                        else // passive element
                        {

                            str = "Click passive element " + c.ToString() + " " + newMenuName[c] + " " + str;
                            globalStr = str;
                            DrawingContext dc = ContextHelpMod(false, ref canMenu);
                            MenuVisual(ref dc);
                            dc.Close();
                             Application.Current.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Input, new Action(delegate { }));
                            stateMenu[c] = 2;
                            return;
                        }

                    }
            }
        }
    } // menu

    void DrawMenuVisual(int state)
    {
        DrawingContext dc = ContextHelpMod2(!true, ref canMenu);
        MenuVisual(ref dc, state);
        dc.Close();
        Application.Current.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Input, new Action(delegate { }));
        static DrawingContext ContextHelpMod2(bool isInit, ref Canvas cTmp)
        {
            if (!isInit) cTmp.Children.Clear();
            DrawingVisualElement drawingVisual = new();
            cTmp.Children.Add(drawingVisual);
            return drawingVisual.drawingVisual.RenderOpen();
        }
    }

    void Window_SizeChanged(object sender, SizeChangedEventArgs e)
    {
        canCurrent.Children.Clear();
        canRuler.Children.Clear();
        SetWindow();
        DrawParallelCoordinates();

        DrawingContext dc = ContextHelpMod(false, ref canMenu);
        MenuVisual(ref dc);
        dc.Close();

        cntrl.ruleFeature = -1;
    }

    void Mouse_Up(object sender, MouseEventArgs e)
    {
        click = false;
        // new menu
        if (true)
        {
            int gpy = (int)e.GetPosition(this).Y, gpx = (int)e.GetPosition(this).X;
            Menu(gpx, gpy, false, false, true);
            lastStateG = -1;
        }

        if (cntrl.ruleFeature == -1) return;

        double y = e.GetPosition(this).Y;

        SetRule();

        void SetRule()
        {
            if (0 < cntrl.lastY - y) // min to max - down to up
                DrawRule((y < ys ? ys : y), cntrl.lastY);

            if (0 > cntrl.lastY - y)// max to min - up to down
                DrawRule(cntrl.lastY, (y - ys > height ? ys + height : y));

            void DrawRule(double start, double end)
            {
                double max_feature = maxVal[cntrl.ruleFeature], min_feature = minVal[cntrl.ruleFeature];
                double max_rule = max_feature + ((Math.Min(start, end) - ys) / height) * (min_feature - max_feature);
                double min_rule = max_feature + ((Math.Max(start, end) - ys) / height) * (min_feature - max_feature);

                DrawingContext dc = ContextHelpMod(true, ref canRuler);

                if (cntrl.ruleLabel != 1)
                {
                    rules.Add(new Rules { max = max_rule, min = min_rule, feature = cntrl.ruleFeature, label = cntrl.ruleLabel });
                    dc.DrawRectangle(br[cntrl.ruleLabel], null, new Rect(xs + (cntrl.ruleFeature + 1) * fs - 1, start, 3, end - start));
                }

                if (cntrl.ruleLabel == 1)
                {
                    if (cntrl.ruleFeature > 3)
                    {
                        ranges[cntrl.ruleFeature - 4].minMax = ((float)min_rule, (float)max_rule);

                        minVal[cntrl.ruleFeature] = (float)min_rule;
                        maxVal[cntrl.ruleFeature] = (float)max_rule;

                    }

                    for (int i = 0; i < dataLength; i++)
                        foreach (var rule in rules) // check if rule is touched
                        {
                            var val = trainData[i * features + rule.feature];
                            if (val >= rule.min && val <= rule.max)
                            {
                                isOut[i] = true;
                                break;
                            }
                        }

                    DrawParallelCoordinates("ranges[cntrl.ruleFeature - 4] = " + (cntrl.ruleFeature - 4) + $"min_rule {min_rule}, max_rule {max_rule}");
                }

                if (cntrl.ruleLabel == 2)
                {
                    // test rules
                    for (int i = 0; i < dataLength; i++)
                        foreach (var rule in rules) // check if rule is touched
                        {
                            var val = trainData[i * features + rule.feature];
                            if (val >= rule.min && val <= rule.max)
                            {
                                isOut[i] = true; break;
                            }
                        }

                    DrawParallelCoordinates("cntrl.ruleLabel == 2");
                }

                cntrl.ruleFeature = -1;

                dc.Close();
                canCurrent.Children.Clear();

            }
            return;
        }
    }
    private void Mouse_Wheel(object sender, MouseWheelEventArgs e)
    {
        if (click) { return; }
        int delta = e.Delta;

        if (++cntrl.ruleLabel > 2)
            cntrl.ruleLabel = 1;
        newMenuName[7] = cntrl.ruleLabel == 1 ? "Take" : "Hide";

        canMenu.Children.Clear();
        DrawingContext dc = ContextHelpMod(false, ref canMenu);
        MenuVisual(ref dc);
        dc.Close();
        DrawParallelCoordinates(delta + " ranger styles" + newMenuName[7]);
    }

    void Mouse_Move(object sender, MouseEventArgs e)
    {
        int y = (int)e.GetPosition(this).Y, x = (int)e.GetPosition(this).X;
        bool mouseButtonState = e.LeftButton == MouseButtonState.Pressed;
        // prevent overloading

        // new menu
        if (y < ys && x < menuWidth + 50)
        {
            Menu(x, y, mouseButtonState,
                // false,
                true, false);
            return;
        }

        SelectRule();

        void SelectRule()
        {
            if (cntrl.ruleFeature != -1 && y != cntrl.lastPoint)
            {
                cntrl.lastPoint = y;
                DrawingContext dc = ContextHelpMod(false, ref canCurrent);
                for (int j = 0; j < features; j++)
                    if (x > (j + 1) * fs - 15 && x < (j + 1) * fs + 25 + 15)
                    {
                        if (0 < cntrl.lastY - y)
                        {
                            if (y < ys) y = ys;
                            dc.DrawRectangle(br[cntrl.ruleLabel], null, new Rect((j + 1) * fs + 8, y, 16, cntrl.lastY - y));
                        }
                        if (0 > cntrl.lastY - y)
                        {
                            if (y > ys + height) y = ys + height;
                            dc.DrawRectangle(br[cntrl.ruleLabel], null, new Rect((j + 1) * fs + 8, cntrl.lastY, 16, y - cntrl.lastY));
                        }
                        cntrl.ruleFeature = j; break;
                    }
                dc.Close();
            }
        }
    }

    void Mouse_Down(object sender, MouseButtonEventArgs e)
    {

        click = true;
        // new menu
        int x = (int)e.GetPosition(this).X, y = (int)e.GetPosition(this).Y;
        if (y < ys && x < menuWidth + 50)
        {
            Menu(x, y, true, false, false);
            return;
        }

        // count thickness
        if (BoundsCheck(x, y, (10 + 80) * 9 + xs - 5, ys + height + 25, 10)) // + count line thickness
        {
            if (style == 5)
            {
                if (countThickness >= 10) countThickness = 1;
                countThickness *= 1.5f;
                DrawParallelCoordinates($"countThickness = {countThickness:F3}"); return;
            }
            else
            {
                if (++lineStyles > 2) lineStyles = 0;
                DrawParallelCoordinates($"lineStyles = {lineStyles}"); return;
            }
        }
        if (BoundsCheck(x, y, (10 + 80) * 9 + xs - 5, ys + height + 36, 10)) // - count line thickness
        {
            if (style == 5)
            {
                if (countThickness <= 0.01f) return;
                countThickness *= 0.75f;
                DrawParallelCoordinates($"countThickness = {countThickness:F3}"); return;
            }
            else
            {
                if (--lineStyles < 0) lineStyles = 2;
                DrawParallelCoordinates($"lineStyles = {lineStyles}"); return;
            }
        }

        if (featureEngineering)
        {
            for (int i = 0; i < featureState.Length - 1; i++)
                if (BoundsCheck2(x, y, (int)(i * fs) + xs, (int)(ys - 13), 10, 10))
                {
                    if (featureMode == -1)
                    {
                        featureNames[features - 1] = featureNames[i];
                        // feed new feature
                        maxVal[features - 1] = maxVal[i];
                        minVal[features - 1] = minVal[i];
                        for (int j = 0; j < dataLength; j++)
                            trainData[(j + 1) * features - 1] = trainData[j * features + i];

                        DrawParallelCoordinates("feature = " + i.ToString()); return;
                    }
                    if (featureMode == 0)
                    {
                        featureMode = -1;
                        for (int j = 0; j < dataLength; j++)
                            trainData[(j + 1) * features - 1] += trainData[j * features + i];
                        AddFeatureMode("+");
                        DrawParallelCoordinates("feature = " + i.ToString()); return;
                    }
                    if (featureMode == 1)
                    {
                        featureMode = -1;
                        for (int j = 0; j < dataLength; j++)
                            trainData[(j + 1) * features - 1] -= trainData[j * features + i];
                        AddFeatureMode("-");
                        DrawParallelCoordinates("feature = " + i.ToString()); return;
                    }
                    if (featureMode == 2)
                    {
                        featureMode = -1;
                        for (int j = 0; j < dataLength; j++)
                            trainData[(j + 1) * features - 1] *= trainData[j * features + i];
                        // feed new feature
                        AddFeatureMode("*");
                        DrawParallelCoordinates("feature = " + i.ToString()); return;
                    }
                    void AddFeatureMode(string str)
                    {
                        featureNames[features - 1] += str + featureNames[i];
                        // feed new feature
                        var tempMax = maxVal[features - 1];
                        var tempMin = minVal[features - 1];
                        for (int j = 0; j < dataLength; j++)
                        {
                            var val = trainData[(j + 1) * features - 1];
                            if (val > tempMax) tempMax = val;
                            if (val < tempMin) tempMin = val;
                        }
                        // if (tempMax == 0) tempMax = 0;
                        // featureState[^1] = (tempMin != tempMax) ? true : false;
                        maxVal[features - 1] = tempMax;
                        minVal[features - 1] = tempMin;
                    }
                }
            // + 
            if (BoundsCheck2(x, y, (int)(fs * (features - 1)) + xs + 3 + 0 * 12, (int)(ys - 13), 10, 10))
            {
                featureMode = 0; DrawParallelCoordinates("featureMode = " + featureMode.ToString()); return;
            }
            // -
            if (BoundsCheck2(x, y, (int)(fs * (features - 1)) + xs + 3 + 1 * 12, (int)(ys - 13), 10, 10))
            {
                featureMode = 1; DrawParallelCoordinates("featureMode = " + featureMode.ToString()); return;
            }
            // *
            if (BoundsCheck2(x, y, (int)(fs * (features - 1)) + xs + 3 + 2 * 12, (int)(ys - 13), 10, 10))
            {
                featureMode = 2; DrawParallelCoordinates("featureMode = " + featureMode.ToString()); return;
            }
            // =
            if (BoundsCheck2(x, y, (int)(fs * (features - 1)) + xs + 3 + 3 * 12, (int)(ys - 13), 10, 10))
            {
                featureEngineering = false;
                featureMode = -1;
                DrawParallelCoordinates("Create new feature"); return;
            }
        }

        if (BoundsCheck2(x, y, (int)(fs * features) + xs + 3, (int)(ys - 13), 10, 10))
        {
            // add feature
            if (!featureEngineering)
            {
                featureEngineering = true;
                // Extend maxVal, minVal, and featureNames arrays
                float[] updatedMaxVal = new float[features + 1];
                float[] updatedMinVal = new float[features + 1];
                string[] updatedFeatureNames = new string[features + 1];

                Array.Copy(maxVal, updatedMaxVal, features);
                Array.Copy(minVal, updatedMinVal, features);
                Array.Copy(featureNames, updatedFeatureNames, features);

                // Add the empty feature at the end
                updatedMaxVal[features] = 1.0f; // Set appropriate default value
                updatedMinVal[features] = 0.0f; // Set appropriate default value
                updatedFeatureNames[features] = ""; // Set appropriate name

                // Extend trainData array
                float[] updatedTrainData = new float[trainData.Length + dataLength * (features + 1)];
                Array.Copy(trainData, updatedTrainData, trainData.Length);

                // Iterate over trainLabels and add empty feature values
                for (int i = 0, c = 0; i < dataLength; i++)
                {
                    for (int j = 0; j < features; j++)
                        updatedTrainData[c++] = trainData[i * features + j];
                    // Assign a value for the empty feature
                    updatedTrainData[c++] = GetRandomFloat(0, 1); // Set appropriate default value
                }

                // Update variables with the new values
                maxVal = updatedMaxVal;
                minVal = updatedMinVal;
                //  maxVal[features] = 0;

                featureNames = updatedFeatureNames;
                trainData = updatedTrainData;
                features = features + 1;

                SetMaxMin();

                isOut = new bool[trainData.Length];
                featureState = new bool[features];

                for (int i = 0; i < featureState.Length; i++)
                    featureState[i] = true;

                SetWindow();
            }

            DrawParallelCoordinates("features = " + features.ToString()); 
            return;
        }

        // check buttons and if clicked activate action
        if (SetMaxMinFeature()) return;

        if (CheckButtons()) return;

        ActivateRule();

        if (ClearRules()) return;
        //  ClearRules();

        // define label from feature
        if (BoundsCheck2(x, y, xs + 95 + (10 + 80) * 3, 3, 80, 20)) // + count line thickness
        {
            if (++labelStyleID >= features) labelStyleID = 0;
            DrawParallelCoordinates("Label: " + labelStyleID); return;
        }

        bool SetMaxMinFeature()
        {
            double gap = 0.5 * (fs - 4 * 12) + 1;
            for (int i = 0; i < featureState.Length; i++)
            {
                int yHeight = ys + height + 7, xWidth = (int)(i * fs + gap) + xs;
                if (BoundsCheck(x, y, xWidth + 0 * 12, yHeight, 10)) // max ▲
                {
                    var maxMin = maxVal[i] - minVal[i];
                    maxVal[i] -= maxMin * 0.1f;
                    minVal[i] -= maxMin * 0.1f;
                    DrawParallelCoordinates(); return true;
                }
                if (BoundsCheck(x, y, xWidth + 1 * 12, yHeight, 10)) // max +
                {
                    maxVal[i] -= maxVal[i] * 0.1f;
                    minVal[i] += maxVal[i] * 0.1f;
                    DrawParallelCoordinates(); return true;
                }
                if (BoundsCheck(x, y, xWidth + 2 * 12, yHeight, 10)) // min -
                {
                    maxVal[i] += maxVal[i] * 0.1f;
                    minVal[i] -= maxVal[i] * 0.1f;
                    DrawParallelCoordinates(); return true;
                }
                if (BoundsCheck(x, y, xWidth + 3 * 12, yHeight, 10)) // min ▼
                {
                    var maxMin = maxVal[i] - minVal[i];
                    maxVal[i] += maxMin * 0.1f;
                    minVal[i] += maxMin * 0.1f;
                    DrawParallelCoordinates(); return true;
                }
            }
            return false;
        }

        bool CheckButtons()

        {
            double gap = 0;
            if (!featureEngineering)
                for (int i = 0; i < featureState.Length; i++)
                    if (BoundsCheck2(x, y, (int)(i * fs + gap) + xs, (int)(ys - 13), 10, 10))
                    {
                        featureState[i] = !featureState[i];
                        DrawParallelCoordinates("feature = " + i.ToString() + " is " + featureState[i].ToString()); return true;
                    }

            // visual style count button
            if (BoundsCheck2(x, y, xs + (10 + 80) * 8, ys + height + 25, 80, 20))
            {
                style++;
                if (style >= styleNames.Length) style = 0;

                DrawParallelCoordinates("Style: " + styleNames[style]);
                return true;
            }

            // max min data 
            if (BoundsCheck2(x, y, xs + (10 + 80) * 7, ys + height + 25, 80, 20))
            {
                for (int featureIndex = 0; featureIndex < features; featureIndex++)
                {
                    minVal[featureIndex] = float.MaxValue;
                    maxVal[featureIndex] = float.MinValue;
                }
                // max min data
                for (int j = 0; j < features; j++)
                    for (int i = 0; i < dataLength; i++)
                    {
                        if (isOut[i]) continue;

                        //   if (trainData[i * features + j] <= maxVal[j] && trainData[i * features + j] >= minVal[j])
                        {
                            var value = trainData[i * features + j];
                            if (value > maxVal[j]) maxVal[j] = value;
                            if (value < minVal[j]) minVal[j] = value;
                        }
                    }
                DrawParallelCoordinates("max min data");
                return true;
            }

            // button NormalizeData
            if (BoundsCheck2(x, y, xs + (10 + 80) * 6, ys + height + 25, 80, 20))
            {

                // Normalize the trainData array
                NormalizeData(trainData, minVal, maxVal);
                DrawParallelCoordinates("NormalizeData");
                return true;
            }
            static void NormalizeData//01
                (float[] trainData, float[] minValues, float[] maxValues)
            {
                for (int i = 0; i < trainData.Length / minValues.Length; i++)
                {
                    for (int j = 0; j < minValues.Length; j++)
                    {
                        float minValue = minValues[j];
                        float maxValue = maxValues[j];
                        float normalizedValue = (trainData[i * minValues.Length + j] - minValue) / (maxValue - minValue);
                        trainData[i * minValues.Length + j] = normalizedValue;
                    }
                }
                for (int i = 0; i < minValues.Length; i++) maxValues[i] = 1;
                for (int i = 0; i < minValues.Length; i++) minValues[i] = 0;
            }

            static void NormalizeDataOneMinusOne
                (float[] trainData, float[] minValues, float[] maxValues)
            {
                for (int i = 0; i < trainData.Length / minValues.Length; i++)
                {
                    for (int j = 0; j < minValues.Length; j++)
                    {
                        float minValue = minValues[j];
                        float maxValue = maxValues[j];
                        float normalizedValue = (trainData[i * minValues.Length + j] - minValue) / (maxValue - minValue);
                        trainData[i * minValues.Length + j] = normalizedValue * 2 - 1;
                    }
                }
                for (int i = 0; i < minValues.Length; i++) maxValues[i] = 1;
                for (int i = 0; i < minValues.Length; i++) minValues[i] = -1;
            }

            // button change label
            if (BoundsCheck2(x, y, xs + (10 + 80) * 0, ys + height + 25, 80, 20))
            {
                if (++cntrl.ruleLabel > 1)
                    cntrl.ruleLabel = 0;

                DrawParallelCoordinates("Label changed to " + (cntrl.ruleLabel));
                return true;
            }
            // button test rules
            if (BoundsCheck2(x, y, xs + (10 + 80) * 1, ys + height + 25, 80, 20))
            {
                // test rules
                for (int i = 0; i < dataLength; i++)
                    foreach (var rule in rules) // check if rule is touched
                    {
                        var val = trainData[i * features + rule.feature];
                        if (val >= rule.min && val <= rule.max)
                        {
                            isOut[i] = true; break;
                        }
                    }
                DrawParallelCoordinates("Refresh");
                return true;
            }
            // button save rules
            if (BoundsCheck2(x, y, xs + (10 + 80) * 2, ys + height + 25, 80, 20))
            {
                Microsoft.Win32.SaveFileDialog dlg = new Microsoft.Win32.SaveFileDialog();
                dlg.FileName = "myfirstRules3.txt";
                if (dlg.ShowDialog() == true)
                    using (StreamWriter writer = new StreamWriter(dlg.FileName))
                        foreach (var rule in rules)
                            writer.WriteLine($"{rule.max},{rule.min},{rule.feature},{rule.label}");

                DrawParallelCoordinates("Save rules"); return true;
            }
            // button load rules
            if (BoundsCheck2(x, y, xs + (10 + 80) * 3, ys + height + 25, 80, 20))
            {
                Microsoft.Win32.OpenFileDialog ofd = new Microsoft.Win32.OpenFileDialog();
                if (ofd.ShowDialog() == true)
                    using (StreamReader reader = new StreamReader(ofd.FileName))
                    {
                        string line;
                        while ((line = reader.ReadLine()) != null)
                        {
                            string[] parts = line.Split(',');
                            if (parts.Length == 4)
                            {
                                Rules rule = new Rules
                                {
                                    max = double.Parse(parts[0]),
                                    min = double.Parse(parts[1]),
                                    feature = int.Parse(parts[2]),
                                    label = int.Parse(parts[3])
                                };
                                rules.Add(rule);
                            }
                        }
                    }
                DrawParallelCoordinates("Load rules"); return true;
            }
            // button save dataset
            if (BoundsCheck2(x, y, xs + (10 + 80) * 4, ys + height + 25, 80, 20))
            {
                var filePath = @"C:\ID_2024\";
                Microsoft.Win32.SaveFileDialog dlg = new Microsoft.Win32.SaveFileDialog();
                dlg.FileName = filePath;
                if (dlg.ShowDialog() == true)
                {
                    int ftCnt = 0;
                    filePath = dlg.FileName; // Update the file path with the chosen file name

                    using (StreamWriter writer = new StreamWriter(filePath))
                    {
                        // Write the attribute names in the first line
                        List<string> selectedFeatureNames = new List<string>();
                        List<double> selectedMaxVal = new List<double>();
                        List<double> selectedMinVal = new List<double>();

                        for (int j = 0; j < features; j++)
                        {
                            if (featureState[j])
                            {
                                ftCnt++;
                                selectedFeatureNames.Add(featureNames[j]);
                                selectedMaxVal.Add(maxVal[j]);
                                selectedMinVal.Add(minVal[j]);
                            }
                        }

                        writer.WriteLine(string.Join(",", selectedFeatureNames));

                        // Write the maximum values in the second line
                        writer.WriteLine(string.Join(",", selectedMaxVal));

                        // Write the minimum values in the third line
                        writer.WriteLine(string.Join(",", selectedMinVal));

                        // Save data + label in the file
                        for (int i = 0; i < dataLength; i++)
                        {
                            if (isOut[i]) continue;

                            StringBuilder lineBuilder = new StringBuilder();

                            for (int j = 0, id = i * features; j < features; j++)
                            {
                                if (!featureState[j]) continue; // Skip if featureState[j] is false

                                double data = trainData[id + j];
                                if (data > maxVal[j])
                                    lineBuilder.Append(maxVal[j]);
                                else if (data < minVal[j])
                                    lineBuilder.Append(minVal[j]);
                                else
                                    lineBuilder.Append(data);

                                lineBuilder.Append(",");
                            }

                            // Write the line to the file
                            writer.WriteLine(lineBuilder.ToString());
                        }
                        writer.Close();
                    }
                }
                DrawParallelCoordinates("Save dataset"); return true;
            }
            // button load dataset
            if (BoundsCheck2(x, y, xs + (10 + 80) * 5, ys + height + 25, 80, 20))
            {
                Microsoft.Win32.OpenFileDialog ofd = new Microsoft.Win32.OpenFileDialog();
                if (ofd.ShowDialog() == true)
                {
                    var lines = File.ReadAllLines(ofd.FileName);

                    // Read the attribute names from the first line
                    featureNames = lines[0].Split(',');

                    // Read the maximum values from the second line
                    maxVal = lines[1].Split(',').Select(float.Parse).ToArray();

                    // Read the minimum values from the third line
                    minVal = lines[2].Split(',').Select(float.Parse).ToArray();

                    int numAttributes = featureNames.Length;

                    // Initialize the data and label arrays based on the number of lines
                    trainData = new float[(lines.Length - 3) * numAttributes];
                    // trainLabels = new int[lines.Length - 3];

                    // Read the data and labels
                    for (int i = 3; i < lines.Length; i++)
                    {
                        string[] parts = lines[i].Split(',');
                        if (parts.Length == numAttributes + 1)
                            for (int j = 0; j < numAttributes; j++)
                            {
                                trainData[(i - 3) * numAttributes + j] = float.Parse(parts[j]);
                            }
                    }
                }

                // set range to data range
                ranges = new Ranges[maxVal.Length - 4];
                for (int i = 0; i < maxVal.Length - 4; i++)
                {
                    var mm = (minVal[i + 4], maxVal[i + 4]);
                    ranges[i].minMax = mm;
                }

                // prepare data

                // set new mean
                testAccMean = 0;
                for (int i = 0; i < dataLength; i++)
                    testAccMean += trainData[i * maxVal.Length + labelStyleID];
                testAccMean /= dataLength;

                isOut = new bool[dataLength];

                features = maxVal.Length;
                featureState = new bool[features];
                for (int i = 0; i < features; i++)
                    featureState[i] = true;

                SetWindow();

                DrawParallelCoordinates("Load dataset"); return true;
            }

            return false;
        }
        bool BoundsCheck2(int x, int y, int width, int height, int paddingW, int paddingH) =>
                    x >= width && x <= width + paddingW && y >= height && y <= height + paddingH;
        void ActivateRule()
        {
            // left button was clicked
            if (e.ChangedButton == MouseButton.Left)
                // check inside pc bounds, then check if feature is clicked
                if (x > xs && x < xs + features * fs && y > ys && y < ys + height)
                {
                    cntrl.ruleFeature = -1;
                    for (int j = 0; j < features; j++)
                        if (x > (j + 1) * fs - 15 && x < (j + 1) * fs + 25 + 15)
                        {
                            cntrl.ruleFeature = j;
                            cntrl.lastY = y; return;
                        }
                }
        }
        bool ClearRules()
        {
            if (e.ChangedButton == MouseButton.Right)
            {
                DrawParallelCoordinates("ClearRules()");
                canRuler.Children.Clear();
                rules.Clear(); // removes all rules
                for (int i = 0; i < isOut.Length; i++) isOut[i] = false;

                return true;
            }
            return false;
        }
        bool BoundsCheck(int x, int y, int width, int height, int padding) =>
    x >= width && x <= width + padding && y >= height && y <= height + padding;

    }
    void DrawParallelCoordinates(string str = "")
    {
        DrawingContext dc = ContextHelpMod(false, ref canVisual);

        // old
        Rect(ref dc, font, xs, ys + height + 30 + 25, 530, 35);
        Rect(ref dc, RGB(0, 0, 0), xs + 1, ys + height + 30 + 25 + 1, 530 - 2, 35 - 2);
        Text(ref dc, str, 11, font, xs + 5, ys + height + 55 + 4);

        if (style > 4)
            DrawDistributionCounts();
        else
        {
            int len = trainData.Length / features;
            float currentSize = penSize * 0.125f;
            float currentBoost = 1.0f / boost;
            float min = minVal[labelStyleID], max = maxVal[labelStyleID];

            for (int lb = 0; lb < len - 0; lb++)
            {
                if (isOut[lb]) continue;
                int id = lb * features;

                float label = Math.Clamp(trainData[id + labelStyleID], min, max);
                float prob = (label - min) / (max - min);
                Brush clr = clrarr[Math.Clamp((int)(prob * ColorSize), 0, ColorSize - 1)];

                float size = lineStyles switch
                {
                    0 => currentSize, // def
                    1 => MathF.Pow(1 - prob * (1 - prob) * 2, boost) * currentSize, // bounds
                    2 => MathF.Pow(prob * prob, boost * 0.1f) * currentSize, // gradations
                    3 => (MathF.Pow(1 - prob * (1 - prob) * 2, boost) * currentSize + MathF.Pow(prob * prob, boost * 0.1f) * currentSize) / 2, // tune
                    _ => MathF.Pow(1 - prob, boost * 0.1f) * currentSize // invert
                };

                float startLine = ys + height - height * prob;

                Pen pen = new(clr, size + 0.05f);

                for (int j = 0; j < features; j++)
                {
                    if (!featureState[j]) continue;
                    float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];
                    value = (value < minV) ? minV : (value > maxV) ? maxV : value;
                    float pixelPos = ys + height - height * ((value - minV) / (maxV - minV));
                    switch (style)
                    {
                        case 0:
                            Line2(dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                            startLine = pixelPos;
                            break;
                        case 1:
                            Line2(dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                            break;
                        case 2:
                            Line2(dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            break;
                        case 3:
                            Line2(dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            Line2(dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            break;
                        case 4:
                            Line2(dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            Line2(dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            startLine = pixelPos;
                            break;
                    }
                    /*
                    switch (style)
                    {
                        case 0:
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                            startLine = pixelPos;
                            break;
                        case 1:
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                            break;
                        case 2:
                            Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            break;
                        case 3:
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            break;
                        case 4:
                            Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            startLine = pixelPos;
                            break;
                    }
                    */
                }
            }


        }
        void DrawDistributionCounts//WithoutStates
    ()
        {
            float currentSize = penSize;

            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

            int h = (int)MathF.Round
                (height / currentSize);
            // 1. init counts and maxCounts for each label
            float[] means = new float[features * h], meanCounts = new float[features * h];

            // 2. translate values into count height id of each data feature
            for (int i = 0; i < dataLength; i++)
            {
                if (isOut[i]) continue;
                int id = i * features;
                float prob = (trainData[id + labelStyleID] - minVal[labelStyleID]) * maxMinusMin[labelStyleID];


                float size1 = lineStyles switch
                {
                    0 => currentSize,
                    1 => MathF.Pow(1 - prob * (1 - prob) * 2, currentSize * currentSize) * currentSize,
                    2 => prob * prob * currentSize,
                    3 => ( // currentSize +
                    MathF.Pow(1 - prob * (1 - prob) * 2, currentSize) * currentSize +
                    prob * prob * currentSize) / 2,

                    _ => (1 - prob) * (1 - prob) * currentSize
                };

                for (int j = 0; j < features; j++)
                    if (trainData[id + j] <= maxVal[j] && trainData[id + j] >= minVal[j])
                    {
                        int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1)) + j * h;
                        means[idx] += trainData[id + labelStyleID] * size1 * prob;
                        meanCounts[idx] += 1 * size1 * prob;
                    }
            }

            float[] maxCounts = new float[features];
            // 3. get max of each feature
            for (int j = 0; j < features; j++)
                for (int i = 0; i < h; i++)
                {
                    float count = meanCounts[i + j * h];
                    if (count > maxCounts[j]) maxCounts[j] = count;
                }

            float min = minVal[labelStyleID], max = maxVal[labelStyleID];
              float pixel = (height) / MathF.Round((height) / currentSize);
         //   float pixel = height / (height / (float)currentSize);

            // 4. draw line with length and color intensity of the line based on counts
            for (int j = 0; j < features; j++)
            {
                float maxCount = maxCounts[j];
                for (int i = 0; i < h; i++)
                {
                    var meanCount = meanCounts[i + j * h];
                    if (meanCount == 0) continue;
                    var probability = meanCount / maxCount;
                    var mean = means[i + j * h] / meanCount;
                    Brush clr = clrarr[Math.Clamp((int)((mean - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                    float pixelPos = (ys + height - ((i * pixel) + pixel * 0.5f)// - pixel * 0.5f
                        );
                    Pen pen = new(clr, pixel - 0.5f);
                    Line2(dc, pen, 15 + (j) * fs, pixelPos, 15 + (j + 0.05) * fs + probability * fs * 0.95, pixelPos);
                }
            }
        }
        void DrawDistributionCountsNew
    ()
        {
            float currentSize = penSize * 0.15f;
            float size = MathF.Sqrt(penSize * penSize);

            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

            int h = (int)MathF.Round(height / size);
            // 1. init counts and maxCounts for each label
            float[] means = new float[features * h];
            float[] meanCounts = new float[features * h];


            // 2. translate values into count height id of each data feature
            for (int i = 0; i < dataLength; i++)
            {
                if (isOut[i]) continue;
                int id = i * features;
                float prob = (trainData[id + labelStyleID] - minVal[labelStyleID]) * maxMinusMin[labelStyleID];


                float size1 = lineStyles switch
                {
                    0 => currentSize,
                    1 => MathF.Pow(1 - prob * (1 - prob) * 2, currentSize * currentSize) * currentSize,
                    2 => prob * prob * currentSize,
                    3 => ( // currentSize +
                    MathF.Pow(1 - prob * (1 - prob) * 2, currentSize) * currentSize +
                    prob * prob * currentSize) / 2,

                    _ => (1 - prob) * (1 - prob) * currentSize
                };

                for (int j = 0; j < features; j++)
                    if (featureState[j])
                        if (trainData[id + j] <= maxVal[j] && trainData[id + j] >= minVal[j])
                        {
                            int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1)) + j * h;
                            // int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1));
                            //   idx = Math.Clamp(idx, 0, h - 1) + j * h; // Ensure the index is within bounds
                            //   float prob = idx / (h - 1);

                            //  Brush clr = clrarr[Math.Clamp((int)(prob * ColorSize), 0, ColorSize - 1)];
                            means[idx] += trainData[id + labelStyleID] * size1 * prob;
                            meanCounts[idx] += 1 * size1 * prob;
                        }
            }


            float[] maxCounts = new float[features];
            // 3. get max of each feature
            for (int j = 0; j < features; j++)
                if (featureState[j])
                    for (int i = 0; i < h; i++)
                    {
                        float count = meanCounts[i + j * h];
                        if (count > maxCounts[j]) maxCounts[j] = count;
                    }

            float min = minVal[labelStyleID], max = maxVal[labelStyleID];
            float pixel = height / MathF.Round(height / size);
            // 4. draw line with length and color intensity of the line based on counts
            for (int j = 0; j < features; j++)
                if (featureState[j])
                {
                    float maxCount = maxCounts[j];
                    for (int i = 0; i < h; i++)
                    {
                        var meanCount = meanCounts[i + j * h];
                        if (meanCount == 0) continue;
                        var probability = meanCount / maxCount;
                        var mean = means[i + j * h] / meanCount;
                        Brush clr = clrarr[Math.Clamp((int)((mean - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                        double pixelPos = (ys + height - ((i * pixel)) - pixel * 0.5f);
                        Pen pen = new(clr, pixel - 0.5f);
                        Line2(dc, pen, 15 + (j) * fs, pixelPos, 15 + (j + 0.05) * fs + probability * fs * 0.95, pixelPos);
                    }
                }
        }
        void DrawDistributionCounts1()
        {
            float size = MathF.Sqrt(penSize * penSize);

            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

            int h = (int)MathF.Round(height / size);
            // 1. init counts and maxCounts for each label
            float[] means = new float[features * h];
            float[] meanCounts = new float[features * h];

            // 2. translate values into count height id of each data feature
            for (int i = 0; i < dataLength; i++)
            {
                if (isOut[i]) continue;

                for (int j = 0, id = i * features; j < features; j++)
                    if (featureState[j])
                        if (trainData[id + j] <= maxVal[j] && trainData[id + j] >= minVal[j])
                        {
                            int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1)) + j * h;
                            // int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1));
                            //   idx = Math.Clamp(idx, 0, h - 1) + j * h; // Ensure the index is within bounds
                            means[idx] += trainData[id + labelStyleID];
                            meanCounts[idx] += 1;
                        }
            }

            float min = minVal[labelStyleID], max = maxVal[labelStyleID];
            float[] maxCounts = new float[features];
            // 3. get max of each feature
            for (int j = 0; j < features; j++)
                if (featureState[j])
                    for (int i = 0; i < h; i++)
                    {
                        float count = meanCounts[i + j * h];
                        if (count > maxCounts[j]) maxCounts[j] = count;
                    }


            float pixel = height / MathF.Round(height / size);
            // 4. draw line with length and color intensity of the line based on counts
            for (int j = 0; j < features; j++)
                if (featureState[j])
                {
                    float maxCount = maxCounts[j];
                    for (int i = 0; i < h; i++)
                    {
                        var meanCount = meanCounts[i + j * h];
                        if (meanCount == 0) continue;
                        var probability = meanCount / maxCount;
                        var mean = means[i + j * h] / meanCount;
                        Brush clr = clrarr[Math.Clamp((int)((mean - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                        double pixelPos = (ys + height - ((i * pixel)) - pixel * 0.5f);
                        Pen pen = new(clr, pixel - 0.5f);
                        Line2(dc, pen, 15 + (j) * fs, pixelPos, 15 + (j + 0.05) * fs + probability * fs * 0.95, pixelPos);
                    }
                }
        }


        void DrawDistributionCountsOld()
        {
            float size = MathF.Sqrt(penSize * penSize);

            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

            int h = (int)MathF.Round(height / size);
            // 1. init counts and maxCounts for each label
            float[] means = new float[features * h];
            int[] meanCounts = new int[features * h];

            // 2. translate values into count height id of each data feature
            for (int i = 0; i < dataLength; i++)
            {
                if (isOut[i]) continue;

                for (int j = 0, id = i * features; j < features; j++)
                    if (featureState[j])
                        if (trainData[id + j] <= maxVal[j] && trainData[id + j] >= minVal[j])
                        {
                            int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1)) + j * h;
                            // int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1));
                            //   idx = Math.Clamp(idx, 0, h - 1) + j * h; // Ensure the index is within bounds
                            float prob = idx / (h - 1);
                            Brush clr = clrarr[Math.Clamp((int)(prob * ColorSize), 0, ColorSize - 1)];
                            means[idx] += trainData[id + labelStyleID];
                            meanCounts[idx] += 1;
                        }
            }

            float min = minVal[labelStyleID], max = maxVal[labelStyleID];
            float[] maxCounts = new float[features];
            // 3. get max of each feature
            for (int j = 0; j < features; j++)
                if (featureState[j])
                    for (int i = 0; i < h; i++)
                    {
                        int count = meanCounts[i + j * h];
                        if (count > maxCounts[j]) maxCounts[j] = count;
                    }


            float pixel = height / MathF.Round(height / size);
            // 4. draw line with length and color intensity of the line based on counts
            for (int j = 0; j < features; j++)
                if (featureState[j])
                {
                    float maxCount = maxCounts[j];
                    for (int i = 0; i < h; i++)
                    {
                        var meanCount = meanCounts[i + j * h];
                        if (meanCount == 0) continue;
                        var probability = meanCount / maxCount;
                        var mean = means[i + j * h] / meanCount;
                        Brush clr = clrarr[Math.Clamp((int)((mean - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                        double pixelPos = (ys + height - ((i * pixel)) - pixel * 0.5f);
                        Pen pen = new Pen(clr, pixel - 0.5f);
                        Line2(dc, pen, 15 + (j) * fs, pixelPos, 15 + (j + 0.05) * fs + probability * fs * 0.95, pixelPos);
                    }
                }
        }

        // todo show grid on/off
        DrawGridInfo();


        DrawButtons();

        void DrawButtons()
        {
            byte b = 36;
            var buttonBG = RGB(b, b, b);

            //  DrawButton(ref dc, font, buttonBG, labelStyle[labelStyleID], 9, xs + 95, 3, 80, 20, 3);

            string styleName = "";
            if (cntrl.ruleLabel == 0)
            {
                styleName = "Set range";
            }
            if (cntrl.ruleLabel == 1)
            {
                styleName = "Take range";
            }
            if (cntrl.ruleLabel == 2)
            {
                styleName = "Remove data";
            }

            if (!true)
            {

                DrawButton(ref dc, br[cntrl.ruleLabel], buttonBG, styleName, 9, xs, ys + height + 25, 80, 20, 0);

                DrawButton(ref dc, font, buttonBG, "Refresh", 9, xs, ys + height + 25, 80, 20, 1);
                DrawButton(ref dc, font, buttonBG, "Save Rules", 9, xs, ys + height + 25, 80, 20, 2);
                DrawButton(ref dc, font, buttonBG, "Load Rules", 9, xs, ys + height + 25, 80, 20, 3);
                DrawButton(ref dc, font, buttonBG, "Save Dataset", 9, xs, ys + height + 25, 80, 20, 4);
                DrawButton(ref dc, font, buttonBG, "Load Dataset", 9, xs, ys + height + 25, 80, 20, 5);
                DrawButton(ref dc, font, buttonBG, "Normalize Dataset", 9, xs, ys + height + 25, 80, 20, 6);
                DrawButton(ref dc, font, buttonBG, "Max Min Data", 9, xs, ys + height + 25, 80, 20, 7);
                DrawButton(ref dc, font, buttonBG, styleNames[style], 9, xs, ys + height + 25, 80, 20, 8);

                // count thickness
                Rect(ref dc, buttonBG, (10 + 80) * 9 + xs - 5, ys + height + 25, 10, 10);
                Text(ref dc, "+", 11, font, (int)((10 + 80) * 9) + xs - 4, ys + height + 25 - 2);
                Rect(ref dc, buttonBG, (10 + 80) * 9 + xs - 5, ys + height + 36, 10, 10);
                Text(ref dc, "-", 13, font, (int)((10 + 80) * 9) + xs + -3, ys + height + 36 - 3);

            }

            void DrawButton(ref DrawingContext dc, Brush rgb, Brush buttonBG, string str, int strSz, int x, int y, int width, int height, int bttnNumber)
            {
                x += (10 + width) * bttnNumber;
                Rect(ref dc, rgb, x, y, width, height);
                Rect(ref dc, buttonBG, x + 1, y + 1, width - 2, height - 2); // Ruler
                Text(ref dc, str, strSz, font, x + 4, y + 5);
            }


            double gap = 0.5 * (fs - 4 * 12) + 1;

            // background feat resolution
            for (int j = 0; j < 4; j++)
                for (int i = 0; i < featureState.Length; i++)
                    Rect(ref dc, buttonBG, (int)(i * fs + gap) + xs + j * 12 + 0, (int)(ys + height) + 7, 10, 10);

            // buttons feat resolution
            for (int i = 0; i < featureState.Length; i++)
            {
                Text(ref dc, "▲", 9, font, (int)(i * fs + gap) + xs + 0 * 12 + 1, ys + height - 1 + 8);
                Text(ref dc, "+", 11, font, (int)(i * fs + gap) + xs + 1 * 12 + 1, ys + height - 2 + 8);
                Text(ref dc, "-", 13, font, (int)(i * fs + gap) + xs + 2 * 12 + 2, ys + height - 3 + 8);
                Text(ref dc, "▼", 9, font, (int)(i * fs + gap) + xs + 3 * 12 + 1, ys + height - 1 + 8);
            }

            // feat eng
            if (!true)
            {
                if (featureEngineering)
                {
                    for (int i = 0; i < featureState.Length - 1; i++)
                    {
                        Rect(ref dc, buttonBG, (int)(i * fs) + xs, (int)(ys - 13), 10, 10);
                        Rect(ref dc, RGB(168, 212, 255), (int)(i * fs) + xs + 1, (int)(ys - 12), 8, 8);
                    }

                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 0 * 12, (int)(ys - 13), 10, 10);
                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 1 * 12, (int)(ys - 13), 10, 10);
                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 2 * 12, (int)(ys - 13), 10, 10);
                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 3 * 12, (int)(ys - 13), 10, 10);

                    Text(ref dc, "+", 11, font, (int)(fs * (features - 1)) + xs + 4 + 0 * 12, (int)(ys - 13) - 1);
                    Text(ref dc, "-", 13, font, (int)(fs * (features - 1)) + xs + 5 + 1 * 12, (int)(ys - 13) - 2);
                    Text(ref dc, "*", 9, font, (int)(fs * (features - 1)) + xs + 6 + 2 * 12, (int)(ys - 13) + 2);
                    Text(ref dc, "=", 9, font, (int)(fs * (features - 1)) + xs + 4 + 3 * 12, (int)(ys - 13) - 0);
                }
                else
                {
                    Rect(ref dc, RGB(128, 128, 128), (int)(fs * features) + xs + 3, (int)(ys - 13), 10, 10);
                    Rect(ref dc, font, (int)(fs * features) + 4 + xs, (int)(ys - 12), 8, 8);

                    for (int i = 0; i < featureState.Length; i++)
                    {
                        Rect(ref dc, RGB(128, 128, 128), (int)(i * fs) + xs, (int)(ys - 13), 10, 10);
                        Rect(ref dc, featureState[i] ? font : Brushes.Black, (int)(i * fs) + xs + 1, (int)(ys - 12), 8, 8);
                    }
                }
            }

        }

        dc.Close();

        return;

        void DrawGridInfo()
        {
            var fnt = RGB(224, 224, 224);
            // draw info lines and labels
            for (int j = 0; j < features; j++)
            {
                float x = 14.5f + (j + 1) * fs;
                if (showGrid) dc.DrawLine(new Pen(fnt, 1.0), new Point(x + 1, ys), new Point(x + 1, ys + height));
                //  Rect(ref dc, font, (int)x, (int)ys, 1, (int)height);
                // dc.DrawRectangle(font, null, new Rect(x, ys, 0.5, height));
                var min = minVal[j];
                double range = maxVal[j] - min;

                for (int i = 0, cats = 10; i < cats + 1; i++) // accuracy lines 0, 20, 40...
                {
                    double yGrph = ys + height - i * (height / (double)cats);
                    double val = range / cats * i + min;
                    Line(ref dc, new Pen(br[cntrl.ruleLabel], 1.0), x - 5, yGrph, x - 1, yGrph);
                   
                    if (showValues)
                    {
                        if (j <= 1)
                            Text(ref dc, val.ToString("F2"), 8, fnt, (int)(x - TextWidth(val.ToString("F2"), 7) - 6), (int)yGrph - 4);
                        else if (j > 3 && val * val >= 1)
                            Text(ref dc, val.ToString("F0"), 8, fnt, (int)(x - TextWidth(val.ToString("F0"), 7) - 6), (int)yGrph - 4);
                        else
                            Text(ref dc, val.ToString("F4"), 8, fnt, (int)(x - TextWidth(val.ToString("F4"), 7) - 6), (int)yGrph - 4);
                    }
                }
                // test mean
                if (j == 1)
                {
                    double yGrph2 = ys + (1 - ((testAccMean - min) / range)) * height;
                    dc.DrawRectangle(Brushes.CornflowerBlue, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));
                }
            }

            // draw top mean
            if (showMeans)
            {
                for (int i = 0; i < maxVal.Length; i++)
                {
                    double x = 14.5 + (i + 1) * fs - fs * 0.5 + 15;
                    var min = minVal[i];
                    double range = maxVal[i] - min;

                    double yGrph2 = ys + (1 - ((statHi[i].Mean() - min) / range)) * height;
                    // dc.DrawRectangle(Brushes.Gold, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));

                    var varY = (statHi[i].StandardDeviation() / maxVal[i]) * height * 0.1f + 1;
                    dc.DrawEllipse(Brushes.Black, null, new Point(x - 15, yGrph2 - 2), 16.0, varY + 1);
                    dc.DrawEllipse(Brushes.Gold, null, new Point(x - 15, yGrph2 - 2), 15.0, varY);

                    yGrph2 = ys + (1 - ((statLo[i].Mean() - min) / range)) * height;
                    // dc.DrawRectangle(Brushes.RoyalBlue, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));
                    varY = (statLo[i].StandardDeviation() / maxVal[i]) * height * 0.1f + 1;
                    dc.DrawEllipse(Brushes.Black, null, new Point(x - 15, yGrph2 - 2), 16.0, varY + 2);
                    dc.DrawEllipse(Brushes.RoyalBlue, null, new Point(x - 15, yGrph2 - 2), 15.0, varY);
                }
            }

            const int fntSz = 10;
           if(showValues) for (int i = 0; i < features; i++)
            {
                var strNames = featureNames[i] + $" ({testAccMean:F1}%|{highscore:F1}%)";
                if (i == labelStyleID && i == 1)
                    Text(ref dc, strNames, fntSz, Brushes.Gold, (int)(15 + (i + 0) * fs + (fs - TextWidth(strNames, fntSz)) * 0.5f), ys - 16);
                else if (i == labelStyleID)
                    Text(ref dc, featureNames[i], fntSz, Brushes.Gold, (int)(15 + (i + 0) * fs + (fs - TextWidth(featureNames[i], fntSz)) * 0.5f), ys - 16);
                else if (i <= 3)
                    Text(ref dc, featureNames[i], fntSz, Brushes.LightGray, (int)(15 + (i + 0) * fs + (fs - TextWidth(featureNames[i], fntSz)) * 0.5f), ys - 16);
                else
                    Text(ref dc, featureNames[i], fntSz, Brushes.RoyalBlue, (int)(15 + (i + 0) * fs + (fs - TextWidth(featureNames[i], fntSz)) * 0.5f), ys - 16);
            }

            for (int i = 0; i < -features; i++)
            {
                var strNames = featureNames[i] + $" ({testAccMean:F1}%|{highscore:F1}%)";
                if (i == labelStyleID && i == 1)
                    Text(ref dc, strNames, fntSz, Brushes.Gold, (int)(12 + (i + 1) * fs - TextWidth(strNames, fntSz)), ys - 14);
                else if (i == labelStyleID)
                    Text(ref dc, featureNames[i], fntSz, Brushes.Gold, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
                else if (i <= 3)
                    Text(ref dc, featureNames[i], fntSz, Brushes.LightGray, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
                else
                    Text(ref dc, featureNames[i], fntSz, Brushes.RoyalBlue, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
            }
        }
        double TextWidth(string text, int fontSize) =>
            new FormattedText(text, CultureInfo.CurrentCulture, FlowDirection.LeftToRight, tf, fontSize, Brushes.Black, 0).WidthIncludingTrailingWhitespace;

        // todo 1
        void DrawParallelCoordinatesLocal()
        {

            int len = trainData.Length / features;

            double yh = ys + height;
            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);
            // Add more colors for other labels if needed
            float min = minVal[labelStyleID], max = maxVal[labelStyleID];

            for (int i = 0, lb = 0; i < len; i += featureState.Length, lb++)
            {

                if (isOut[i]) continue;
                int id = i * featureState.Length; // Pen pen = pens[lab];
                StreamGeometry linesGeometry = new();
                using (StreamGeometryContext linesContext = linesGeometry.Open())
                {
                    for (int j = 0; j < featureState.Length; j++)
                    {
                        if (!featureState[j]) continue;
                        double pixelPos = yh - height * ((trainData[id + j] - minVal[j]) * (maxMinusMin[j]));

                        linesContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, false);
                    }
                }

                float label = trainData[id + labelStyleID];

                // Adjust label if outside the range
                label = (label < min) ? min : (label > max) ? max : label;

                Brush clr = clrarr[Math.Clamp((int)((label / max) * ColorSize), 0, ColorSize - 1)];


                dc.DrawGeometry(null, new Pen(clr, ColorSize), linesGeometry);
                /*
                Pen pen = new(br[lab], 0.5);
                for (int j = 0; j < featureState.Length; j++)
                {
                    // if (!featureState[j]) continue;
                    double pixelPos = yh - height * ((trainData[id + j] - minVal[j]) * (maxMinusMin[j]));
                    Line2(dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                }*/
            }
        }


        void Line2(DrawingContext dc, Pen pen, double xl, double yl, double xr, double yr) => dc.DrawLine(pen, new Point(xl, yl), new Point(xr, yr));
    }

    void DrawParallelCoordinatesVerbose
        (string str = "")
    {
        DrawingContext dc = ContextHelpMod(false, ref canVisual);

        // old
        Rect(ref dc, font, xs, ys + height + 30 + 25, 530, 35);
        Rect(ref dc, RGB(0, 0, 0), xs + 1, ys + height + 30 + 25 + 1, 530 - 2, 35 - 2);
        Text(ref dc, str, 11, font, xs + 5, ys + height + 55 + 4);

        if (style > 4)
            DrawDistributionCounts();
        else
        if (style <= 4)
        {
            int len = trainData.Length / features;
            float currentSize = penSize * 0.125f;

            if (style <= 4)
            {
                float yh = ys + height;

                float[] maxMinusMin = new float[maxVal.Length];
                for (int i = 0; i < maxMinusMin.Length; i++)
                    maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

                float min = minVal[labelStyleID], max = maxVal[labelStyleID];

                // Add more colors for other labels if needed
                for (int i = 0; i < len; i++)
                {
                    if (isOut[i]) continue;

                    int id = i * features;
                    float label = trainData[id + labelStyleID];

                    // Adjust label if outside the range
                    label = (label < min) ? min : (label > max) ? max : label;

                    float labelRange = max - min;
                    float startLine = ys + height - (label - min) * (height / labelRange);

                    Brush clr = clrarr[Math.Clamp((int)((label - min) / (labelRange / ColorSize)), 0, ColorSize - 1)];
                  
                    float prob = (label - min) / (max - min);

                    float size = lineStyles switch
                    {
                        0 => currentSize,
                        1 => MathF.Pow(1 - prob * (1 - prob) * 2, currentSize * currentSize) * currentSize,
                        _ => prob * prob * currentSize
                    };

                    Pen pen = new(clr, size); // pen.Freeze();

                    if (!true)
                    {
                        PathGeometry pathGeometry = new();
                        PathFigureCollection figures = [];

                        PathFigure pathFigure = new()
                        {
                            StartPoint = new Point(15, startLine),
                            IsClosed = false,
                            IsFilled = false,
                           
                        };

                        for (int j = 0; j < features; j++)
                        {
                            if (!featureState[j]) continue;
                            float normalizedValue = (trainData[id + j] - minVal[j]) * maxMinusMin[j];
                            float pixelPos = yh - height * normalizedValue;
                            pathFigure.Segments.Add(new LineSegment(new Point(15 + (j + 1) * fs, pixelPos), true));
                        }

                        figures.Add(pathFigure);
                        pathGeometry.Figures = figures;

                        dc.DrawGeometry(null, pen, pathGeometry);
                    }
                    else if (true)
                    {
                        PathGeometry pathGeometry = new PathGeometry();
                        PathFigure pathFigure = new PathFigure();
                        bool isFirst = true;
                        float pixelPos = yh - height * (trainData[id + 0] - minVal[0]) * maxMinusMin[0];
                        pathFigure.Segments.Add(new LineSegment(new Point(15 + 0 * fs, pixelPos), true));
                        for (int j = 0; j < features; j++)
                        {
                            if (!featureState[j]) continue;

                            float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];
                            value = (value < minV) ? minV : (value > maxV) ? maxV : value;
                            pixelPos = ys + height - height * ((value - minV) / (maxV - minV));
                               
                            pathFigure.Segments.Add(new LineSegment(new Point(15 + j * fs + fs, pixelPos), true));
                            

                            startLine = pixelPos;
                        }

                        pathGeometry.Figures.Add(pathFigure);
                        pen.Freeze(); // Freeze the pen for performance
                        dc.DrawGeometry(null, pen, pathGeometry);
                        /*
                        GeometryGroup geometryGroup = new GeometryGroup();
                        float pixelPos = yh - height * (trainData[id + 0] - minVal[0]) * maxMinusMin[0];
                        for (int j = 0; j < features; j++)
                        {
                            if (!featureState[j]) continue;
                            float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];
                            value = (value < minV) ? minV : (value > maxV) ? maxV : value;
                            pixelPos = ys + height - height * ((value - minV) / (maxV - minV));
                            geometryGroup.Children.Add(new LineGeometry(new Point(15 + j * fs, startLine), new Point(15 + j * fs + fs, pixelPos)));                            
                            startLine = pixelPos;
                        }
                        pen.Freeze(); // Freeze the pen for performance
                        dc.DrawGeometry(null, pen, geometryGroup);
                        */
                    }
                    else if (true)
                    {
                        StreamGeometry streamGeometry = new();
                        using StreamGeometryContext geometryContext = streamGeometry.Open();
                        {
                            float pixelPos = yh - height * (trainData[id + 0] - minVal[0]) * maxMinusMin[0];

                            geometryContext.BeginFigure(new Point(15, startLine), false, false);
                            startLine = pixelPos;
                            for (int j = 0; j < features; j++)
                            {
                                if (!featureState[j]) continue;

                                float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];
                                value = (value < minV) ? minV : (value > maxV) ? maxV : value;
                                pixelPos = ys + height - height * ((value - minV) / (maxV - minV));
                                geometryContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, !false);
                            }
                        }
                        dc.DrawGeometry(null, pen, streamGeometry);
                    }
                    else if (true)
                    {
                        StreamGeometry streamGeometry = new();
                        using (StreamGeometryContext geometryContext = streamGeometry.Open())
                        {
                            float pixelPos = yh - height * (trainData[id + 0] - minVal[0]) * maxMinusMin[0];

                            geometryContext.BeginFigure(new Point(15, startLine), false, false);
                            startLine = pixelPos;
                            for (int j = 0; j < features; j++)
                            {
                                if (!featureState[j]) continue;

                                float normalizedValue = (trainData[id + j] - minVal[j]) * maxMinusMin[j];

                                pixelPos = yh - height * normalizedValue;

                                // Add line segment to StreamGeometry
                                geometryContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, !false);

                                // Update startLine for the next iteration
                                startLine = pixelPos;
                            }
                        }
                        dc.DrawGeometry(null, pen, streamGeometry);
                    }
                    else
                    {
                        StreamGeometry linesGeometry = new StreamGeometry();

                        using (StreamGeometryContext linesContext = linesGeometry.Open())

                            for (int j = 0; j < features; j++)
                            {
                                if (!featureState[j]) continue;

                                float normalizedValue = (trainData[id + j] - minVal[j]) * maxMinusMin[j];
                                float pixelPos = yh - height * normalizedValue;

                                // Add line segment to StreamGeometry
                                linesContext.BeginFigure(new Point(15 + j * fs, startLine), false, false);
                                linesContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, false);

                                // Update startLine for the next iteration
                                startLine = pixelPos;
                            }

                        linesGeometry.Freeze();
                        // Draw the geometry with the interpolated color
                        dc.DrawGeometry(null, pen, linesGeometry);
                    }
                } // geometry ends
            }
            else
            {
                float min = minVal[labelStyleID], max = maxVal[labelStyleID];

                for (int lb = 0; lb < len - 0; lb++)
                {
                    if (isOut[lb]) continue;
                    int id = lb * features;
                    /*
                    float label = trainData[id + labelStyleID];
                    label = (label < min) ? min : (label > max) ? max : label;
                    float prob = (label - min) / (max - min);
                    Brush clr = clrarr[Math.Clamp((int)(prob * ColorSize), 0, ColorSize - 1)];
                    */
                    float label = Math.Clamp(trainData[id + labelStyleID], min, max);              
                    float prob = (label - min) / (max - min);
                    Brush clr = clrarr[Math.Clamp((int)(prob * ColorSize), 0, ColorSize - 1)];
                    // float prob2 = label / max; Brush clr = clrarr[(int)(prob2 * (ColorSize - 1))];

                    float size = lineStyles switch
                    {
                        0 => currentSize,
                        1 => MathF.Pow(1 - prob * (1 - prob) * 2, currentSize * currentSize) * currentSize,
                        _ => prob * prob * currentSize
                    };

                    float startLine = ys + height - height * prob;

                    Pen pen = new(clr, size + 0.05f);
                    float pixelPos;
                    for (int j = 0; j < features; j++)
                    {
                        if (!featureState[j]) continue;
                        float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];
                        value = (value < minV) ? minV : (value > maxV) ? maxV : value;
                        pixelPos = ys + height - height * ((value - minV) / (maxV - minV));


                        switch (style)
                        {
                            case 0:
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                                startLine = pixelPos;
                                break;
                            case 1:
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                                break;
                            case 2:
                                Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                                break;
                            case 3:
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                                Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                                break;
                            case 4:
                                Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                                startLine = pixelPos;
                                break;
                        }
             
                    }

                    /*
                    for (int j = 0; j < features; j++)
                    {
                        if (!featureState[j]) continue;

                        float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];

                        value = (value < minV) ? minV : (value > maxV) ? maxV : value;

                        pixelPos = ys + height - height * ((value - minV) / (maxV - minV));

                        if (style == 0)
                        {
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                            startLine = pixelPos;
                        }
                        else if (style == 1)
                        {
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                        }
                        else if (style == 2)
                        {
                            Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                        }
                        else if (style == 3)
                        {
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                        }
                        else if (style == 4)
                        {
                            Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            startLine = pixelPos;
                        }
                    }
                    */

                    // messy code
                    /*   for (int j = 0; j < features; j++)
                       {
                           if (!featureState[j]) continue;

                           float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];

                           value = (value < minV) ? minV : (value > maxV) ? maxV : value;

                           pixelPos = ys + height - height * ((value - minV) / (maxV - minV));

                           if (style == 0)
                           {
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                               startLine = pixelPos;
                           }
                           else if (style == 1)
                           {
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                           }
                           else if (style == 2)
                           {
                               Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                           }
                           else if (style == 3)
                           {
                               // 1
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                               // 2
                               Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);

                               // 0 
                               //  Linexxx(ref dc, clr, 0.5, 15 + j * fs + fs * 0.66, startLine, 15 + (j + 1) * fs, pixelPos);
                               //  startLine = pixelPos;

                               // 2
                               //  Linexxx(ref dc, clr, 0.5, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);

                           }
                           else if (style == 4)
                           {
                               // 1
                               // Linexxx(ref dc, clr, 0.5, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                               // 2
                               // Linexxx(ref dc, clr, 0.5, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                               Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                               // 0 
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                               startLine = pixelPos;

                               // 2
                               //  Linexxx(ref dc, clr, 0.5, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);

                           }
                       }
                    */



                }
            }

        }

        void DrawDistributionCounts()
        {
            float size = MathF.Sqrt(penSize * penSize);

            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

            int h = (int)MathF.Round(height / size);
            // 1. init counts and maxCounts for each label
            float[] means = new float[features * h];
            int[] meanCounts = new int[features * h];

            // 2. translate values into count height id of each data feature
            for (int i = 0; i < dataLength; i++)
            {
                if (isOut[i]) continue;

                for (int j = 0, id = i * features; j < features; j++)
                    if (featureState[j])
                        if (trainData[id + j] <= maxVal[j] && trainData[id + j] >= minVal[j])
                        {
                            int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1)) + j * h;
                            // int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1));
                            //   idx = Math.Clamp(idx, 0, h - 1) + j * h; // Ensure the index is within bounds
                            means[idx] += trainData[id + labelStyleID];
                            meanCounts[idx]++;
                        }
            }

            float min = minVal[labelStyleID];
            float max = maxVal[labelStyleID];

            int[] maxCounts = new int[features];
            // 3. get max of each feature
            for (int j = 0; j < features; j++)
                if (featureState[j])
                    for (int i = 0; i < h; i++)
                    {
                        int count = meanCounts[i + j * h];
                        if (count > maxCounts[j]) maxCounts[j] = count;
                    }


            float pixel = height / MathF.Round(height / size);
            // 4. draw line with length and color intensity of the line based on counts
            for (int j = 0; j < features; j++)
                if (featureState[j])
                {
                    float maxCount = (float)maxCounts[j];
                    for (int i = 0; i < h; i++)
                    {
                        var meanCount = meanCounts[i + j * h];
                        if (meanCount == 0) continue;
                        var probability = meanCount / maxCount;
                        var mean = means[i + j * h] / meanCount;
                        Brush clr = clrarr[Math.Clamp((int)((mean - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                        double pixelPos = (ys + height - ((i * pixel)) - pixel * 0.5f);
                        Pen pen = new Pen(clr, pixel - 0.5f);
                        Line2(dc, pen, 15 + (j) * fs, pixelPos, 15 + (j + 0.05) * fs + probability * fs * 0.95, pixelPos);
                    }
                }
        }

        // todo show grid on/off
        DrawGridInfo();

       
        DrawButtons();

        void DrawButtons()
        {
            byte b = 36;
            var buttonBG = RGB(b, b, b);

            //  DrawButton(ref dc, font, buttonBG, labelStyle[labelStyleID], 9, xs + 95, 3, 80, 20, 3);

            string styleName = "";
            if (cntrl.ruleLabel == 0)
            {
                styleName = "Set range";
            }
            if (cntrl.ruleLabel == 1)
            {
                styleName = "Take range";
            }
            if (cntrl.ruleLabel == 2)
            {
                styleName = "Remove data";
            }

            if (!true)
            {

                DrawButton(ref dc, br[cntrl.ruleLabel], buttonBG, styleName, 9, xs, ys + height + 25, 80, 20, 0);

                DrawButton(ref dc, font, buttonBG, "Refresh", 9, xs, ys + height + 25, 80, 20, 1);
                DrawButton(ref dc, font, buttonBG, "Save Rules", 9, xs, ys + height + 25, 80, 20, 2);
                DrawButton(ref dc, font, buttonBG, "Load Rules", 9, xs, ys + height + 25, 80, 20, 3);
                DrawButton(ref dc, font, buttonBG, "Save Dataset", 9, xs, ys + height + 25, 80, 20, 4);
                DrawButton(ref dc, font, buttonBG, "Load Dataset", 9, xs, ys + height + 25, 80, 20, 5);
                DrawButton(ref dc, font, buttonBG, "Normalize Dataset", 9, xs, ys + height + 25, 80, 20, 6);
                DrawButton(ref dc, font, buttonBG, "Max Min Data", 9, xs, ys + height + 25, 80, 20, 7);
                DrawButton(ref dc, font, buttonBG, styleNames[style], 9, xs, ys + height + 25, 80, 20, 8);

                // count thickness
                Rect(ref dc, buttonBG, (10 + 80) * 9 + xs - 5, ys + height + 25, 10, 10);
                Text(ref dc, "+", 11, font, (int)((10 + 80) * 9) + xs - 4, ys + height + 25 - 2);
                Rect(ref dc, buttonBG, (10 + 80) * 9 + xs - 5, ys + height + 36, 10, 10);
                Text(ref dc, "-", 13, font, (int)((10 + 80) * 9) + xs + -3, ys + height + 36 - 3);

            }

            void DrawButton(ref DrawingContext dc, Brush rgb, Brush buttonBG, string str, int strSz, int x, int y, int width, int height, int bttnNumber)
            {
                x += (10 + width) * bttnNumber;
                Rect(ref dc, rgb, x, y, width, height);
                Rect(ref dc, buttonBG, x + 1, y + 1, width - 2, height - 2); // Ruler
                Text(ref dc, str, strSz, font, x + 4, y + 5);
            }


            double gap = 0.5 * (fs - 4 * 12) + 1;

            // background feat resolution
            for (int j = 0; j < 4; j++)
                for (int i = 0; i < featureState.Length; i++)
                    Rect(ref dc, buttonBG, (int)(i * fs + gap) + xs + j * 12 + 0, (int)(ys + height) + 7, 10, 10);

            // buttons feat resolution
            for (int i = 0; i < featureState.Length; i++)
            {
                Text(ref dc, "▲", 9, font, (int)(i * fs + gap) + xs + 0 * 12 + 1, ys + height - 1 + 8);
                Text(ref dc, "+", 11, font, (int)(i * fs + gap) + xs + 1 * 12 + 1, ys + height - 2 + 8);
                Text(ref dc, "-", 13, font, (int)(i * fs + gap) + xs + 2 * 12 + 2, ys + height - 3 + 8);
                Text(ref dc, "▼", 9, font, (int)(i * fs + gap) + xs + 3 * 12 + 1, ys + height - 1 + 8);
            }

            // feat eng
            if (!true)
            {
                if (featureEngineering)
                {
                    for (int i = 0; i < featureState.Length - 1; i++)
                    {
                        Rect(ref dc, buttonBG, (int)(i * fs) + xs, (int)(ys - 13), 10, 10);
                        Rect(ref dc, RGB(168, 212, 255), (int)(i * fs) + xs + 1, (int)(ys - 12), 8, 8);
                    }

                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 0 * 12, (int)(ys - 13), 10, 10);
                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 1 * 12, (int)(ys - 13), 10, 10);
                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 2 * 12, (int)(ys - 13), 10, 10);
                    Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 3 * 12, (int)(ys - 13), 10, 10);

                    Text(ref dc, "+", 11, font, (int)(fs * (features - 1)) + xs + 4 + 0 * 12, (int)(ys - 13) - 1);
                    Text(ref dc, "-", 13, font, (int)(fs * (features - 1)) + xs + 5 + 1 * 12, (int)(ys - 13) - 2);
                    Text(ref dc, "*", 9, font, (int)(fs * (features - 1)) + xs + 6 + 2 * 12, (int)(ys - 13) + 2);
                    Text(ref dc, "=", 9, font, (int)(fs * (features - 1)) + xs + 4 + 3 * 12, (int)(ys - 13) - 0);
                }
                else
                {
                    Rect(ref dc, RGB(128, 128, 128), (int)(fs * features) + xs + 3, (int)(ys - 13), 10, 10);
                    Rect(ref dc, font, (int)(fs * features) + 4 + xs, (int)(ys - 12), 8, 8);

                    for (int i = 0; i < featureState.Length; i++)
                    {
                        Rect(ref dc, RGB(128, 128, 128), (int)(i * fs) + xs, (int)(ys - 13), 10, 10);
                        Rect(ref dc, featureState[i] ? font : Brushes.Black, (int)(i * fs) + xs + 1, (int)(ys - 12), 8, 8);
                    }
                }
            }

        }

        dc.Close();

        return;

        void DrawGridInfo()
        {
            var fnt = RGB(224, 224, 224);
            // draw info lines and labels
            for (int j = 0; j < features; j++)
            {
                float x = 14.5f + (j + 1) * fs;
                if (showGrid) dc.DrawLine(new Pen(fnt, 1.0), new Point(x + 1, ys), new Point(x + 1, ys + height));
                //  Rect(ref dc, font, (int)x, (int)ys, 1, (int)height);
                // dc.DrawRectangle(font, null, new Rect(x, ys, 0.5, height));
                var min = minVal[j];
                double range = maxVal[j] - min;

                for (int i = 0, cats = 10; i < cats + 1; i++) // accuracy lines 0, 20, 40...
                {
                    double yGrph = ys + height - i * (height / (double)cats);
                    double val = range / cats * i + min;
                    Line(ref dc, new Pen(br[cntrl.ruleLabel], 1.0), x - 5, yGrph, x - 1, yGrph);
                    if (showValues)
                    {
                        if (j <= 1)
                            Text(ref dc, val.ToString("F2"), 8, fnt, (int)(x - TextWidth(val.ToString("F2"), 7) - 6), (int)yGrph - 4);
                        else if (j > 3 && val * val >= 1)
                            Text(ref dc, val.ToString("F0"), 8, fnt, (int)(x - TextWidth(val.ToString("F0"), 7) - 6), (int)yGrph - 4);
                        else
                            Text(ref dc, val.ToString("F4"), 8, fnt, (int)(x - TextWidth(val.ToString("F4"), 7) - 6), (int)yGrph - 4);
                    }
                }
                // test mean
                if (j == 1)
                {
                    double yGrph2 = ys + (1 - ((testAccMean - min) / range)) * height;
                    dc.DrawRectangle(Brushes.CornflowerBlue, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));
                }
            }


            const int fntSz = 10;
            for (int i = 0; i < features; i++)
            {
                var strNames = featureNames[i] + $" ({testAccMean:F1}%|{highscore:F1}%)";
                if (i == labelStyleID && i == 1)
                    Text(ref dc, strNames, fntSz, Brushes.Gold, (int)(15 + (i + 0) * fs + (fs - TextWidth(strNames, fntSz)) * 0.5f), ys - 16);
                else if (i == labelStyleID)
                    Text(ref dc, featureNames[i], fntSz, Brushes.Gold, (int)(15 + (i + 0) * fs + (fs - TextWidth(featureNames[i], fntSz)) * 0.5f), ys - 16);
                else if (i <= 3)
                    Text(ref dc, featureNames[i], fntSz, Brushes.LightGray, (int)(15 + (i + 0) * fs + (fs - TextWidth(featureNames[i], fntSz)) * 0.5f), ys - 16);
                else
                    Text(ref dc, featureNames[i], fntSz, Brushes.RoyalBlue, (int)(15 + (i + 0) * fs + (fs - TextWidth(featureNames[i], fntSz)) * 0.5f), ys - 16);
            }

            for (int i = 0; i < -features; i++)
            {
                var strNames = featureNames[i] + $" ({testAccMean:F1}%|{highscore:F1}%)";
                if (i == labelStyleID && i == 1)
                    Text(ref dc, strNames, fntSz, Brushes.Gold, (int)(12 + (i + 1) * fs - TextWidth(strNames, fntSz)), ys - 14);
                else if (i == labelStyleID)
                    Text(ref dc, featureNames[i], fntSz, Brushes.Gold, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
                else if (i <= 3)
                    Text(ref dc, featureNames[i], fntSz, Brushes.LightGray, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
                else
                    Text(ref dc, featureNames[i], fntSz, Brushes.RoyalBlue, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
            }
        }

        double TextWidth(string text, int fontSize) =>
            new FormattedText(text, CultureInfo.CurrentCulture, FlowDirection.LeftToRight, tf, fontSize, Brushes.Black, 0).WidthIncludingTrailingWhitespace;

        // todo 1
        void DrawParallelCoordinatesLocal()
        {

            int len = trainData.Length / features;

            double yh = ys + height;
            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);
            // Add more colors for other labels if needed
            float min = minVal[labelStyleID], max = maxVal[labelStyleID];

            for (int i = 0, lb = 0; i < len; i += featureState.Length, lb++)
            {
                  
                if (isOut[i]) continue;
                int id = i * featureState.Length; // Pen pen = pens[lab];
                StreamGeometry linesGeometry = new();
                using (StreamGeometryContext linesContext = linesGeometry.Open())
                {
                    for (int j = 0; j < featureState.Length; j++)
                    {
                        if (!featureState[j]) continue;
                        double pixelPos = yh - height * ((trainData[id + j] - minVal[j]) * (maxMinusMin[j]));
                 
                        linesContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, false);
                    }
                }

                float label = trainData[id + labelStyleID];

                // Adjust label if outside the range
                label = (label < min) ? min : (label > max) ? max : label;

                Brush clr = clrarr[Math.Clamp((int)((label / max) * ColorSize), 0, ColorSize - 1)];


                dc.DrawGeometry(null, new Pen(clr, ColorSize), linesGeometry);
                /*
                Pen pen = new(br[lab], 0.5);
                for (int j = 0; j < featureState.Length; j++)
                {
                    // if (!featureState[j]) continue;
                    double pixelPos = yh - height * ((trainData[id + j] - minVal[j]) * (maxMinusMin[j]));
                    Line2(dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                }*/
            }
        }

        
        void Line2(DrawingContext dc, Pen pen, double xl, double yl, double xr, double yr) => dc.DrawLine(pen, new Point(xl, yl), new Point(xr, yr));
    }

    void DrawParallelCoordinatesOld
        (string str = "")
    {
        DrawingContext dc = ContextHelpMod(false, ref canVisual);

        // draw console 
        // DrawConsole(240, 15);
        void DrawConsole(int x, int y)
        {
            Rect(ref dc, font, x + 0, y, 530, 35);
            Rect(ref dc, RGB(0, 0, 0), x + 0 + 1, y + 1, 530 - 2, 35 - 2);
            Text(ref dc, str, 11, font, x + 0 + 5, y + 4);
        }

      //  Text(ref dc, $"Trained networks = {numberOfActiveNets}", 11, font, 240, 15 + 13 * 0);
       // Text(ref dc, $"Highscore = {highscore:F2}%", 11, font, 240, 15 + 13 * 1);
        //   Text(ref dc, $"testAccMean = {testAccMean:F2}%", 11, font, 240, 55 + 13 * 2);

        // old
        Rect(ref dc, font, xs, ys + height + 30 + 25, 530, 35);
        Rect(ref dc, RGB(0, 0, 0), xs + 1, ys + height + 30 + 25 + 1, 530 - 2, 35 - 2);
        Text(ref dc, str, 11, font, xs + 5, ys + height + 55 + 4);

        if (style > 4)
            DrawDistributionCounts();
        else
        if (style <= 4)
        {
            int len = trainData.Length / features;

            double startLine, pixelPos;

            float currentSize = penSize * 0.1f;

            if (style == 10)
            {
                double yh = ys + height;

                float[] maxMinusMin = new float[maxVal.Length];
                for (int i = 0; i < maxMinusMin.Length; i++)
                    maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);
               
                float min = minVal[labelStyleID];
                float max = maxVal[labelStyleID];

                // Add more colors for other labels if needed
                for (int i = 0, lb = 0; i < len; i++, lb++)
                {
                    if (isOut[lb]) continue;

                    int id = lb * features;
                    float label = trainData[id + labelStyleID];

                    // Adjust label if outside the range
                    if (label < min || label > max)
                        label = Math.Clamp(label, min, max);

                    float labelRange = max - min;
                    startLine = ys + height - (label - min) * (height / labelRange);

                    Brush clr = clrarr[Math.Clamp((int)((label - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                    Pen pen = new(clr, currentSize); // pen.Freeze();

                    if (true)
                    {
                        PathGeometry pathGeometry = new PathGeometry();
                        PathFigureCollection figures = new PathFigureCollection();

                        PathFigure pathFigure = new PathFigure
                        {
                            StartPoint = new Point(15, startLine),
                            IsClosed = false, IsFilled = false
                        };

                        for (int j = 0; j < features; j++)
                        {
                            if (!featureState[j]) continue;

                            double normalizedValue = (trainData[id + j] - minVal[j]) * maxMinusMin[j];

                            pixelPos = yh - height * normalizedValue;

                            pathFigure.Segments.Add(new LineSegment(new Point(15 + (j + 1) * fs, pixelPos), true));
                        }

                        figures.Add(pathFigure);
                        pathGeometry.Figures = figures;

                        dc.DrawGeometry(null, pen, pathGeometry);




                    }

                    else
                    if (true)
                    {                      
                        StreamGeometry streamGeometry = new();
                        using (StreamGeometryContext geometryContext = streamGeometry.Open())
                        {
                            double normalizedValue = (trainData[id + 0] - minVal[0]) * maxMinusMin[0];
                            pixelPos = yh - height * normalizedValue;


                            geometryContext.BeginFigure(new Point(15, startLine), false, false);
                            startLine = pixelPos;
                            for (int j = 0; j < features; j++)
                            {
                                if (!featureState[j]) continue;

                                normalizedValue = (trainData[id + j] - minVal[j]) * maxMinusMin[j];
                                pixelPos = yh - height * normalizedValue;

                                // Add line segment to StreamGeometry
                                geometryContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, false);


                                // Update startLine for the next iteration
                                startLine = pixelPos;
                            }
                        }
                        dc.DrawGeometry(null, pen, streamGeometry);
                    }
                     else
                    {
                        StreamGeometry linesGeometry = new StreamGeometry();

                        using (StreamGeometryContext linesContext = linesGeometry.Open())

                            for (int j = 0; j < features; j++)
                            {
                                if (!featureState[j]) continue;

                                double normalizedValue = (trainData[id + j] - minVal[j]) * maxMinusMin[j];
                                pixelPos = yh - height * normalizedValue;

                                // Add line segment to StreamGeometry
                                linesContext.BeginFigure(new Point(15 + j * fs, startLine), false, false);
                                linesContext.LineTo(new Point(15 + (j + 1) * fs, pixelPos), true, false);

                                // Update startLine for the next iteration
                                startLine = pixelPos;
                            }

                        linesGeometry.Freeze();
                        // Draw the geometry with the interpolated color
                        dc.DrawGeometry(null, pen, linesGeometry);
                    }


                }
            }
            else
            {
                float min = minVal[labelStyleID];
                float max = maxVal[labelStyleID];


                for (int lb = 0; lb < len - 0; lb++)
                {
                    if (isOut[lb]) continue;
                    int id = lb * features;

                    float label = trainData[id + labelStyleID];
                    label = (label < min) ? min : (label > max) ? max : label;

                    /*if (label < min)
                        label = min;
                    else if (label > max)
                        label = max;
                    */
                    // clr = InterpolateColor(label, min, max);
                    // clr = clrarr[(int)Math.Round(((label - min) / (max - min)) * (clrRange - 1))];

                    /* int numBins = clrRange; // The number of bins you want
                     int binIndex = (int)Math.Floor((label - min) / ((max - min) / numBins));
                     binIndex = Math.Max(0, Math.Min(numBins - 1, binIndex)); // Ensure the bin index is within bounds
                     clr = clrarr[binIndex];*/

                    Brush clr = clrarr[Math.Clamp((int)((label - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];

                    /*
                    float prob = (label - min) / (max - min);
                    prob = 1 - (prob * (1 - prob) * 2);
                    prob = prob * prob;
                    float size = prob * 1.9f + 0.1f;
                    Pen pen = new Pen(clr, size);
                    startLine = ys + height - height * prob;
                    */

                    float prob = (label - min) / (max - min);
                    float size = prob * 1.9f + 0.1f;

                    if (lineStyles == 0)
                    {
                        size = currentSize;
                        startLine = ys + height - height * prob;
                    }
                    else if (lineStyles == 1)
                    {
                        // prob = prob * prob;
                        /*  size =
                              (1 - (prob * (1 - prob) * 2)) * (1 - (prob * (1 - prob) * 2)) *
                              (1 - (prob * (1 - prob) * 2)) * (1 - (prob * (1 - prob) * 2)) *
                              (1 - (prob * (1 - prob) * 2)) * (1 - (prob * (1 - prob) * 2)) * 3;*/
                        // size = MathF.Pow((1 - (prob * (1 - prob) * 2)), currentSize);
                        float newPen = (1 - (prob * (1 - prob) * 2));
                        for (int i = 0; i < (int)currentSize - 1; i++)
                        {
                            newPen *= newPen;
                        }
                        newPen *= currentSize;
                        size =
                              (1 - (prob * (1 - prob) * 2)) * (1 - (prob * (1 - prob) * 2)) *
                              (1 - (prob * (1 - prob) * 2)) * (1 - (prob * (1 - prob) * 2)) *
                              (1 - (prob * (1 - prob) * 2)) * (1 - (prob * (1 - prob) * 2)) * (penSize / 10.0f);
                        //  size = MathF.Pow((1 - (prob * (1 - prob) * 2)), currentSize) * currentSize;
                        //   size = newPen;
                        //  size = (1 - (prob * (1 - prob) * 2)) * penSize;
                        //   prob = 1 - (prob * (1 - prob) * 2);
                        startLine = ys + height - height * prob;
                        //  prob = prob * prob;
                    }
                    else
                    {
                        size = prob * currentSize ;
                        startLine = ys + height - height * prob;
                    }
                    Pen pen = new(clr, size + 0.05f);


                    for (int j = 0; j < features; j++)
                    {
                        if (!featureState[j]) continue;

                        float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];

                        value = (value < minV) ? minV : (value > maxV) ? maxV : value;

                        pixelPos = ys + height - height * ((value - minV) / (maxV - minV));

                        switch (style)
                        {
                            case 0:
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                                startLine = pixelPos;
                                break;
                            case 1:
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                                break;
                            case 2:
                                Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                                break;
                            case 3:
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                                Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                                break;
                            case 4:
                                Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                                Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                                startLine = pixelPos;
                                break;
                        }
                    }
                    
                    /*
                    for (int j = 0; j < features; j++)
                    {
                        if (!featureState[j]) continue;

                        float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];

                        value = (value < minV) ? minV : (value > maxV) ? maxV : value;

                        pixelPos = ys + height - height * ((value - minV) / (maxV - minV));

                        if (style == 0)
                        {
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                            startLine = pixelPos;
                        }
                        else if (style == 1)
                        {
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                        }
                        else if (style == 2)
                        {
                            Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                        }
                        else if (style == 3)
                        {
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                        }
                        else if (style == 4)
                        {
                            Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                            Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                            startLine = pixelPos;
                        }
                    }
                    */

                    // messy code
                    /*   for (int j = 0; j < features; j++)
                       {
                           if (!featureState[j]) continue;

                           float value = trainData[id + j], minV = minVal[j], maxV = maxVal[j];

                           value = (value < minV) ? minV : (value > maxV) ? maxV : value;

                           pixelPos = ys + height - height * ((value - minV) / (maxV - minV));

                           if (style == 0)
                           {
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                               startLine = pixelPos;
                           }
                           else if (style == 1)
                           {
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs, pixelPos);
                           }
                           else if (style == 2)
                           {
                               Line(ref dc, pen, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);
                           }
                           else if (style == 3)
                           {
                               // 1
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                               // 2
                               Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);

                               // 0 
                               //  Linexxx(ref dc, clr, 0.5, 15 + j * fs + fs * 0.66, startLine, 15 + (j + 1) * fs, pixelPos);
                               //  startLine = pixelPos;

                               // 2
                               //  Linexxx(ref dc, clr, 0.5, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);

                           }
                           else if (style == 4)
                           {
                               // 1
                               // Linexxx(ref dc, clr, 0.5, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                               // 2
                               // Linexxx(ref dc, clr, 0.5, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                               Line(ref dc, pen, 15 + j * fs + fs * 0.5, pixelPos, 15 + (j + 1) * fs, pixelPos);
                               // 0 
                               Line(ref dc, pen, 15 + j * fs, startLine, 15 + (j + 1) * fs - fs * 0.5, pixelPos);
                               startLine = pixelPos;

                               // 2
                               //  Linexxx(ref dc, clr, 0.5, 15 + j * fs, pixelPos, 15 + (j + 1) * fs, pixelPos);

                           }
                       }
                    */



                }
            }

        }

        void DrawDistributionCounts()
        {
            float size = MathF.Sqrt(penSize * penSize);

            float[] maxMinusMin = new float[maxVal.Length];
            for (int i = 0; i < maxMinusMin.Length; i++)
                maxMinusMin[i] = 1.0f / (maxVal[i] - minVal[i]);

            int h = (int)MathF.Round(height / size);
            // 1. init counts and maxCounts for each label
            float[] means = new float[features * h];
            int[] meanCounts = new int[features * h];

            // 2. translate values into count height id of each data feature
            for (int i = 0; i < dataLength; i++)
            {
                if (isOut[i]) continue;

                for (int j = 0, id = i * features; j < features; j++)
                    if (featureState[j])
                        if (trainData[id + j] <= maxVal[j] && trainData[id + j] >= minVal[j])
                        {
                            int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1)) + j * h;
                            // int idx = (int)((trainData[id + j] - minVal[j]) * maxMinusMin[j] * (h - 1));
                         //   idx = Math.Clamp(idx, 0, h - 1) + j * h; // Ensure the index is within bounds
                            means[idx] += trainData[id + labelStyleID];
                            meanCounts[idx]++;
                        }
            }

            float min = minVal[labelStyleID];
            float max = maxVal[labelStyleID];

            int[] maxCounts = new int[features];
            // 3. get max of each feature
            for (int j = 0; j < features; j++)
                if (featureState[j])
                    for (int i = 0; i < h; i++)
                    {
                        int count = meanCounts[i + j * h];
                        if (count > maxCounts[j]) maxCounts[j] = count;
                    }


            float pixel = height / MathF.Round(height / size);
            // 4. draw line with length and color intensity of the line based on counts
            for (int j = 0; j < features; j++)
                if (featureState[j])
                {
                    float maxCount = (float)maxCounts[j];
                    for (int i = 0; i < h; i++)
                    {
                        var meanCount = meanCounts[i + j * h];
                        if (meanCount == 0) continue;
                        var probability = meanCount / maxCount;
                        var mean = means[i + j * h] / meanCount;
                        Brush clr = clrarr[Math.Clamp((int)((mean - min) / ((max - min) / ColorSize)), 0, ColorSize - 1)];
                        double pixelPos = (ys + height - ((i * pixel)) - pixel * 0.5f);
                        Pen pen = new Pen(clr, pixel - 0.5f);
                        Line2(dc, pen, 15 + (j) * fs, pixelPos, 15 + (j + 0.05) * fs + probability * fs * 0.95, pixelPos);
                    }
                }
        }

        // todo show grid on/off
        DrawGridInfo();

        DrawButtons();

        void DrawButtons()
        {
            byte b = 36;
            var buttonBG = RGB(b, b, b);

            //  DrawButton(ref dc, font, buttonBG, labelStyle[labelStyleID], 9, xs + 95, 3, 80, 20, 3);

            string styleName = "";
            if (cntrl.ruleLabel == 0)
            {
                styleName = "Set range";
            }
            if (cntrl.ruleLabel == 1)
            {
                styleName = "Take range";
            }
            if (cntrl.ruleLabel == 2)
            {
                styleName = "Remove data";
            }

            DrawButton(ref dc, br[cntrl.ruleLabel], buttonBG, styleName, 9, xs, ys + height + 25, 80, 20, 0);

            DrawButton(ref dc, font, buttonBG, "Refresh", 9, xs, ys + height + 25, 80, 20, 1);
            DrawButton(ref dc, font, buttonBG, "Save Rules", 9, xs, ys + height + 25, 80, 20, 2);
            DrawButton(ref dc, font, buttonBG, "Load Rules", 9, xs, ys + height + 25, 80, 20, 3);
            DrawButton(ref dc, font, buttonBG, "Save Dataset", 9, xs, ys + height + 25, 80, 20, 4);
            DrawButton(ref dc, font, buttonBG, "Load Dataset", 9, xs, ys + height + 25, 80, 20, 5);
            DrawButton(ref dc, font, buttonBG, "Normalize Dataset", 9, xs, ys + height + 25, 80, 20, 6);
            DrawButton(ref dc, font, buttonBG, "Max Min Data", 9, xs, ys + height + 25, 80, 20, 7);
            DrawButton(ref dc, font, buttonBG, styleNames[style], 9, xs, ys + height + 25, 80, 20, 8);

            void DrawButton(ref DrawingContext dc, Brush rgb, Brush buttonBG, string str, int strSz, int x, int y, int width, int height, int bttnNumber)
            {
                x += (10 + width) * bttnNumber;
                Rect(ref dc, rgb, x, y, width, height);
                Rect(ref dc, buttonBG, x + 1, y + 1, width - 2, height - 2); // Ruler
                Text(ref dc, str, strSz, font, x + 4, y + 5);
            }

            double gap = 0.5 * (fs - 4 * 12) + 1;
            for (int j = 0; j < 4; j++)
                for (int i = 0; i < featureState.Length; i++)
                    Rect(ref dc, buttonBG, (int)(i * fs + gap) + xs + j * 12 + 0, (int)(ys + height) + 7, 10, 10);


            // feat resolution
            for (int i = 0; i < featureState.Length; i++)
            {
                Text(ref dc, "▲", 9, font, (int)(i * fs + gap) + xs + 0 * 12 + 1, ys + height - 1 + 8);
                Text(ref dc, "+", 11, font, (int)(i * fs + gap) + xs + 1 * 12 + 1, ys + height - 2 + 8);
                Text(ref dc, "-", 13, font, (int)(i * fs + gap) + xs + 2 * 12 + 2, ys + height - 3 + 8);
                Text(ref dc, "▼", 9, font, (int)(i * fs + gap) + xs + 3 * 12 + 1, ys + height - 1 + 8);
            }

            // count thickness
            Rect(ref dc, buttonBG, (10 + 80) * 9 + xs - 5, ys + height + 25, 10, 10);
            Text(ref dc, "+", 11, font, (int)((10 + 80) * 9) + xs - 4, ys + height + 25 - 2);
            Rect(ref dc, buttonBG, (10 + 80) * 9 + xs - 5, ys + height + 36, 10, 10);
            Text(ref dc, "-", 13, font, (int)((10 + 80) * 9) + xs + -3, ys + height + 36 - 3);

            // feat eng
            if (featureEngineering)
            {
                for (int i = 0; i < featureState.Length - 1; i++)
                {
                    Rect(ref dc, buttonBG, (int)(i * fs) + xs, (int)(ys - 13), 10, 10);
                    Rect(ref dc, RGB(168, 212, 255), (int)(i * fs) + xs + 1, (int)(ys - 12), 8, 8);
                }

                Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 0 * 12, (int)(ys - 13), 10, 10);
                Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 1 * 12, (int)(ys - 13), 10, 10);
                Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 2 * 12, (int)(ys - 13), 10, 10);
                Rect(ref dc, buttonBG, (int)(fs * (features - 1)) + xs + 3 + 3 * 12, (int)(ys - 13), 10, 10);

                Text(ref dc, "+", 11, font, (int)(fs * (features - 1)) + xs + 4 + 0 * 12, (int)(ys - 13) - 1);
                Text(ref dc, "-", 13, font, (int)(fs * (features - 1)) + xs + 5 + 1 * 12, (int)(ys - 13) - 2);
                Text(ref dc, "*", 9, font, (int)(fs * (features - 1)) + xs + 6 + 2 * 12, (int)(ys - 13) + 2);
                Text(ref dc, "=", 9, font, (int)(fs * (features - 1)) + xs + 4 + 3 * 12, (int)(ys - 13) - 0);
            }
            else
            {
                Rect(ref dc, RGB(128, 128, 128), (int)(fs * features) + xs + 3, (int)(ys - 13), 10, 10);
                Rect(ref dc, font, (int)(fs * features) + 4 + xs, (int)(ys - 12), 8, 8);

                for (int i = 0; i < featureState.Length; i++)
                {
                    Rect(ref dc, RGB(128, 128, 128), (int)(i * fs) + xs, (int)(ys - 13), 10, 10);
                    Rect(ref dc, featureState[i] ? font : Brushes.Black, (int)(i * fs) + xs + 1, (int)(ys - 12), 8, 8);
                }
            }
        }

        dc.Close();

        return;

        void DrawGridInfo()
        {
            // draw info lines and labels
            for (int j = 0; j < features; j++)
            {
                double x = 14.5 + (j + 1) * fs;
                if (showGrid) dc.DrawLine(new Pen(font, 1.0), new Point(x + 1, ys), new Point(x + 1, ys + height));
                //  Rect(ref dc, font, (int)x, (int)ys, 1, (int)height);
                // dc.DrawRectangle(font, null, new Rect(x, ys, 0.5, height));
                var min = minVal[j];
                double range = maxVal[j] - min;

                for (int i = 0, cats = 10; i < cats + 1; i++) // accuracy lines 0, 20, 40...
                {
                    double yGrph = ys + height - i * (height / (double)cats);
                    double val = range / cats * i + min;
                    Line(ref dc, new Pen(br[cntrl.ruleLabel], 1.0), x - 5, yGrph, x - 1, yGrph);
                    if (showValues)
                    {
                        if (j <= 1)
                            Text(ref dc, val.ToString("F2"), 8, font, (int)(x - TextWidth(val.ToString("F2"), 7) - 6), (int)yGrph - 4);
                        else if (j > 3 && val * val >= 1)
                            Text(ref dc, val.ToString("F0"), 8, font, (int)(x - TextWidth(val.ToString("F0"), 7) - 6), (int)yGrph - 4);

                        else
                            Text(ref dc, val.ToString("F4"), 8, font, (int)(x - TextWidth(val.ToString("F4"), 7) - 6), (int)yGrph - 4);
                    }
                }
                if (j == 1)
                {

                    double yGrph2 = ys + (1 - ((testAccMean - min) / range)) * height;
                    dc.DrawRectangle(Brushes.CornflowerBlue, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));
                }
            }

            // draw top mean
            if (showMeans)
            {
                for (int i = 0; i < maxVal.Length; i++)
                {
                    double x = 14.5 + (i + 1) * fs - fs * 0.5 + 15;
                    var min = minVal[i];
                    double range = maxVal[i] - min;

                    double yGrph2 = ys + (1 - ((statHi[i].Mean() - min) / range)) * height;
                    // dc.DrawRectangle(Brushes.Gold, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));

                    var varY = (statHi[i].StandardDeviation() / maxVal[i]) * height * 0.1f + 1;
                    dc.DrawEllipse(Brushes.Black, null, new Point(x - 15, yGrph2 - 2), 16.0, varY + 1);
                    dc.DrawEllipse(Brushes.Gold, null, new Point(x - 15, yGrph2 - 2), 15.0, varY);

                    yGrph2 = ys + (1 - ((statLo[i].Mean() - min) / range)) * height;
                    // dc.DrawRectangle(Brushes.RoyalBlue, null, new Rect(x - 30, yGrph2 - 2, 30.0, 3));
                    varY = (statLo[i].StandardDeviation() / maxVal[i]) * height * 0.1f + 1;
                    dc.DrawEllipse(Brushes.Black, null, new Point(x - 15, yGrph2 - 2), 16.0, varY + 2);
                    dc.DrawEllipse(Brushes.RoyalBlue, null, new Point(x - 15, yGrph2 - 2), 15.0, varY);
                }
            }

            // DrawButton(ref dc, br[cntrl.ruleLabel], buttonBG, styleName, 9, xs, ys + height + 25, 80, 20, 0);

            {
                double yGrph = ys + -2;
                double x2 = 15 + (0 + features) * fs + 2;
                //  Line(ref dc, new Pen(br[cntrl.ruleLabel], 1.0), 15, yGrph, x2, yGrph);
            }

            int fntSz = 9;
            for (int i = 0; i < features; i++)
            {
                var strNames = featureNames[i] + $" ({testAccMean:F1}%|{highscore:F1}%)";
                if (i == labelStyleID && i == 1)
                    Text(ref dc, strNames, fntSz, Brushes.Gold, (int)(12 + (i + 1) * fs - TextWidth(strNames, fntSz)), ys - 14);
                else if (i == labelStyleID)
                    Text(ref dc, featureNames[i], fntSz, Brushes.Gold, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
                else if (i <= 3)
                    Text(ref dc, featureNames[i], fntSz, Brushes.LightGray, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
                else
                    Text(ref dc, featureNames[i], fntSz, Brushes.RoyalBlue, (int)(12 + (i + 1) * fs - TextWidth(featureNames[i], fntSz)), ys - 14);
            }
        }

        double TextWidth(string text, int fontSize) =>
            new FormattedText(text, CultureInfo.CurrentCulture, FlowDirection.LeftToRight, tf, fontSize, Brushes.Black,0).WidthIncludingTrailingWhitespace;

        void Line2(DrawingContext dc, Pen pen, double xl, double yl, double xr, double yr) => dc.DrawLine(pen, new Point(xl, yl), new Point(xr, yr));
    }

    void NeuralNetPredictionData()
    {
        int startIndex = 0;
        testAccMean = 0;
        float localScore = stackdata ? highscore : 0;
        int step = (modelSize / 100) * 5;
        float[] trainDataSource = new float[modelSize * features];
        float[] currentTopHi = new float[features], currentTopLo = new float[features];
        float topResultHi = float.MinValue, topResultLo = float.MaxValue;

        for (int i = 0, ii = 0; i < modelSize; i++)
        {
            var PARALLEL = true; 
            var EPOCHS = GetRandomInt((int)ranges[0].minMax.min, (int)ranges[0].minMax.max);
            var TRAINSIZE = GetRandomInt((int)ranges[1].minMax.min, (int)ranges[1].minMax.max);
            var BATCHSIZE = GetRandomInt((int)ranges[2].minMax.min, (int)ranges[2].minMax.max);
            var LEARNINGRATE = GetRandomFloat(ranges[3].minMax.min, ranges[3].minMax.max);
            var MOMENTUM = GetRandomFloat(ranges[4].minMax.min, ranges[4].minMax.max);
            var FACTOR = GetRandomFloat(ranges[5].minMax.min, ranges[5].minMax.max);
            var BPPROB = GetRandomFloat(ranges[6].minMax.min, ranges[6].minMax.max);
            var SEED = GetRandomInt((int)ranges[7].minMax.min, (int)ranges[7].minMax.max);
            var LAYERS = GetRandomInt(1, 2);

            int[] hiddenLayers = new int[LAYERS];
            for (int j = 0; j < hiddenLayers.Length; j++)
                hiddenLayers[j] = GetRandomInt((int)ranges[8 + j].minMax.min, (int)ranges[8 + j].minMax.max);

            int[] network = [784, .. hiddenLayers, 10];

            Net NN = new(network, SEED);

            var (accTraining, timeTraining) = RunTraining(PARALLEL, data.samplesTrainingF, data.LabelsTraining, NN, TRAINSIZE, LEARNINGRATE, MOMENTUM, FACTOR, EPOCHS, BATCHSIZE, BPPROB, SEED);
            var (accTest, timeTest) = RunTest(PARALLEL, data.samplesTestF, data.labelsTest, NN, testSize);

            if (i + 1 > ii || i == modelSize - 1)
            {
                ii = i + step;
                DrawingContext dc = ContextHelpMod(false, ref canMenu);
                MenuVisual(ref dc, 0, (i <= modelSize - 1) ? (float)((1 + i) / (float)modelSize) : -1);
                dc.Close();
                Application.Current.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Render, new Action(delegate { }));
            }

            testAccMean += accTest;
            localScore = accTest > localScore ? accTest : localScore;

            float[] newResult = new float[featureNamesNeuralNetwork.Length];
            newResult[0] = accTraining;
            newResult[1] = accTest;
            newResult[2] = timeTraining;
            newResult[3] = timeTest;           
            newResult[4] = EPOCHS;
            newResult[5] = TRAINSIZE; 
            newResult[6] = BATCHSIZE;
            newResult[7] = LEARNINGRATE;
            newResult[8] = MOMENTUM;
            newResult[9] = FACTOR;
            newResult[10] = BPPROB;
            newResult[11] = SEED;
            // newResult[12] = LAYERS;
            // newResult[13] = NN.weights.Length;
            for (int j = 0; j < network.Length - 2; j++)
                newResult[12 + j] = network[1 + j];

            if (topResultHi <= accTest)
            {
                if (topResultHi == accTest)
                {
                    for (int j = 0; j < currentTopHi.Length; j++)
                        currentTopHi[j] = (currentTopHi[j] + newResult[j]) * 0.5f;
                }
                else
                {
                    topResultHi = accTest;
                    currentTopHi = newResult;
                }
            }
            if (topResultLo >= accTest)
            {
                if (topResultLo == accTest)
                {
                    for (int j = 0; j < currentTopLo.Length; j++)
                        currentTopLo[j] = (currentTopLo[j] + newResult[j]) * 0.5f;
                }
                else
                {
                    topResultLo = accTest;
                    currentTopLo = newResult;
                }
            }

            for (int j = 0; j < features; j++)
                trainDataSource[i * features + j] = newResult[j];
            startIndex += features;
        }

        highscore = localScore;
        numberOfActiveNets = stackdata ? numberOfActiveNets + modelSize : modelSize;
        testAccMean /= modelSize;
        //  testAccMean = (testAccMean2 + testAccMean) / 2; 

        if (!stackdata && statHi != null || statHi == null)
        {
            statHi = new RunningStat[features];
            statLo = new RunningStat[features];
            for (int i = 0; i < features; i++) statHi[i] = new RunningStat();
            for (int i = 0; i < features; i++) statLo[i] = new RunningStat();

            for (int i = 0; i < statHi.Length; i++)
            {                
                statHi[i].Add(currentTopHi[i]);
                statLo[i].Add(currentTopLo[i]);
            }
        }
        else
        {
            for (int i = 0; i < statHi.Length; i++)
            {
                statHi[i].Add(currentTopHi[i]);
                statLo[i].Add(currentTopLo[i]);
            }
        }

        //
        trainData = stackdata ? [.. trainData, .. trainDataSource] : [.. trainDataSource];
        dataLength = trainData.Length / features; // Array.Fill(isOut, true);
        isOut = stackdata ? [.. isOut, .. new bool[dataLength - isOut.Length]] : new bool[dataLength];

        SetMaxMin();
        SetWindow();
    }

    static float GetRandomFloat(float minValue, float maxValue)
    {
        return (float)(new Random().NextDouble() * (maxValue - minValue) + minValue);
    }

    static int GetRandomInt(int minValue, int maxValue)
    {
        return new Random().Next(minValue, maxValue + 1);
    }
    // TRAINING
    static (float acc, float time) RunTraining(bool multiCore, float[] trainData, byte[] trainLabel, // AutoData d,
                        Net NN, int len, float lr, float mom, float FACTOR, int EPOCHS, int BATCHSIZE, float BPPROB, int SEED)
    {
        float[] deltas = new float[NN.weights.Length];

        int[] indices = new int[len];
        for (int i = 0; i < indices.Length; i++)
            indices[i] = i;

        Random rng = new(SEED);

        float acc = 0;

        Stopwatch stopwatch = Stopwatch.StartNew();

        for (int epoch = 0, B = len / BATCHSIZE; epoch < EPOCHS; epoch++, lr *= FACTOR)
        {
            //  Shuffle(indices, rng.Next());
            Random.Shared.Shuffle(indices);
            bool[] c = new bool[B * BATCHSIZE]; // for proper parallel count  
            if (multiCore)
                for (int b = 0; b < B; b++)
                {
                    _ = Parallel.For(b * BATCHSIZE, (b + 1) * BATCHSIZE, x =>
                    {
                        int id = indices[x];
                        byte label = trainLabel[id];
                        bool prediction = Train(trainData.AsSpan().Slice(id * 784, 784), label, NN, deltas, BPPROB);
                        c[x] = prediction;
                    });
                    SGD(NN.weights, deltas, lr, mom);
                }
            else // single core
                for (int b = 0; b < B; b++)
                {
                    for (int x = b * BATCHSIZE, X = (b + 1) * BATCHSIZE; x < X; x++)
                    {
                        int id = indices[x];
                        byte label = trainLabel[id];
                        bool prediction = Train(trainData.AsSpan().Slice(id * 784, 784), label, NN, deltas, BPPROB);
                        c[x] = prediction;
                    }
                    SGD(NN.weights, deltas, lr, mom);
                }
            // if ((epoch + 1) % 10 == 0) PrintInfo("Epoch = " + (1 + epoch).ToString().PadLeft(3) + " |", c.Count(n => n), B * BATCHSIZE, stopwatch);
            int count = c.Count(n => n);
            acc = (float)count / len * 100.0f;
        }
        //   acc /= EPOCHS;
        return (acc, (float)(stopwatch.Elapsed.TotalMilliseconds / 1000.0));

    }

    static void SGD(Span<float> weights, Span<float> delta, float lr, float mom)
    {
        var weightVecArray = MemoryMarshal.Cast<float, Vector512<float>>(weights);
        var deltaVecArray = MemoryMarshal.Cast<float, Vector512<float>>(delta);

        for (int v = 0; v < weightVecArray.Length; v++)
        {
            weightVecArray[v] = deltaVecArray[v] * lr + weightVecArray[v];
            deltaVecArray[v] *= mom;
        }

        for (int w = weightVecArray.Length * Vector512<float>.Count; w < weights.Length; w++)
        {
            weights[w] = delta[w] * lr + weights[w];
            delta[w] *= mom;
        }
    }
    static void Shuffle(Span<int> indices, int seed)
    {
        Random random = new(seed);
        for (int i = indices.Length - 1; i > 0; i--)
        {
            int j = random.Next(i + 1);
            (indices[i], indices[j]) = (indices[j], indices[i]);
        }
    }

    static bool Train(ReadOnlySpan<float> sample, byte target, Net NN, float[] deltas, float probT)
    {
        Span<float> neurons = stackalloc float[NN.neuronLen];

        sample.CopyTo(neurons);

        FeedForward(NN.net, NN.weights, neurons);

        var outs = neurons.Slice(neurons.Length - NN.net[^1], NN.net[^1]);

        int prediction = SoftArgMax(outs);

        if (outs[target] < probT)
        {
            ErrorGradient(outs, target);
            Backprop(neurons, NN.net, NN.weights, deltas);
        }

        return prediction == target;

    }
    static int SoftArgMax(Span<float> neurons)
    {
        int id = 0;
        float max = neurons[0];
        for (int i = 1; i < neurons.Length; i++)
        {
            float n = neurons[i];
            if (n > max) { max = n; id = i; }
        }

        float scale = 0;

        for (int n = 0; n < neurons.Length; n++)
            scale += neurons[n] = MathF.Exp((neurons[n] - max)); // activation then sum up

        scale = 1 / scale; // turns division to multiplication

        for (int n = 0; n < neurons.Length; n++)
            neurons[n] *= scale; // probabilities

        return id; // prediction
    }

    static void ErrorGradient(Span<float> neurons, byte target)
    {
        // for (int i = 0; i < neurons.Length; i++) neurons[i] = target == i ? 1 - neurons[i] : -neurons[i];
        for (int i = 0; i < neurons.Length; i++)
            neurons[i] = i switch { _ when i == target => 1 - neurons[i], _ => -neurons[i] };
    }
    static void Backprop2(Span<float> neurons, ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> deltas)
    {
        // compute gradients and deltas for each layer in one loop, hot!!!
        for (int j = neurons.Length - net[^1], k = neurons.Length, m = weights.Length, i = net.Length - 2; i >= 0; i--)
        {
            int right = net[i + 1], left = net[i];
            k -= right; j -= left; m -= right * left;

            var inputGradients = neurons.Slice(j, left);

            int V = right / Vector256<float>.Count * Vector256<float>.Count;
            var outputGradients = neurons.Slice(k, right);



            for (int l = 0, w = m; l < left; l++, w += right)
            {
                var n = inputGradients[l];
                if (n <= 0) { inputGradients[l] = 0; continue; }
                var inVec = Vector256.Create(n);
                var wts = weights.Slice(w, right);
                var dts = deltas.Slice(w, right);

                var wtsVec = MemoryMarshal.Cast<float, Vector256<float>>(wts.Slice(V));
                var dtsVec = MemoryMarshal.Cast<float, Vector256<float>>(dts.Slice(V));
                var graVec = MemoryMarshal.Cast<float, Vector256<float>>(outputGradients.Slice(V));


                var sumVec = Vector256<float>.Zero;

                for (int v = 0; v < graVec.Length; v++) // SIMD, partial gradient and delta
                {
                    var outGraVec = graVec[v];
                    sumVec = wtsVec[v] * outGraVec + sumVec;
                    dtsVec[v] = inVec * outGraVec + dtsVec[v];
                }

                // changed float result with Vector.Sum() vs. regular approach
                var sum = Vector256.Sum(sumVec);

                for (int r = V; r < wts.Length; r++)
                {
                    var outGraSpan = outputGradients[r];
                    sum = wts[r] * outGraSpan + sum;
                    dts[r] = n * outGraSpan + dts[r];
                }
                inputGradients[l] = sum;
            }
        }
    }
    static void BackpropOK(Span<float> neurons, ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> deltas)
    {
        // compute gradients and deltas for each layer in one loop, hot!!!
        for (int j = neurons.Length - net[^1], k = neurons.Length, m = weights.Length, i = net.Length - 2; i >= 0; i--)
        {
            int right = net[i + 1], left = net[i];
            k -= right; j -= left; m -= right * left;

            var inputGradients = neurons.Slice(j, left);
            var outputGradients = neurons.Slice(k, right);
            for (int l = 0, w = m; l < left; l++, w += right)
            {
                var n = inputGradients[l];
                if (n <= 0) { inputGradients[l] = 0; continue; }
              //  var inVec = Vector256.Create(n);
                var wts = weights.Slice(w, right);
                var dts = deltas.Slice(w, right);

                var wtsVec = MemoryMarshal.Cast<float, Vector256<float>>(wts);
                var dtsVec = MemoryMarshal.Cast<float, Vector256<float>>(dts);
                var graVec = MemoryMarshal.Cast<float, Vector256<float>>(outputGradients);

                var sumVec = Vector256<float>.Zero;

                for (int v = 0; v < graVec.Length; v++) // SIMD, partial gradient and delta
                {
                    var outGraVec = graVec[v];
                    sumVec = wtsVec[v] * outGraVec + sumVec;
                    dtsVec[v] = n * outGraVec + dtsVec[v];
                }

                // changed float result with Vector.Sum() vs. regular approach
                var sum = Vector256.Sum(sumVec);

                for (int r = graVec.Length * Vector256<float>.Count; r < wts.Length; r++)
                {
                    var outGraSpan = outputGradients[r];
                    sum = wts[r] * outGraSpan + sum;
                    dts[r] = n * outGraSpan + dts[r];
                }
                inputGradients[l] = sum;
            }
        }
    }
    static void Backprop(Span<float> neurons, ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> deltas)
    {
      //  var graVec = MemoryMarshal.Cast<float, Vector256<float>>(null);
        // compute gradients and deltas for each layer in one loop, hot!!!
        for (int j = neurons.Length - net[^1], k = neurons.Length, m = weights.Length, i = net.Length - 2; i >= 0; i--)
        {
            int right = net[i + 1], left = net[i];
            k -= right; j -= left; m -= right * left;

            var inputGradients = neurons.Slice(j, left);
            var outputGradients = neurons.Slice(k, right);
            for (int l = 0, w = m; l < left; l++, w += right)
            {
                var n = inputGradients[l];
                if (n <= 0) { inputGradients[l] = 0; continue; }
                //  var inVec = Vector256.Create(n);
                var wts = weights.Slice(w, right);
                var dts = deltas.Slice(w, right);

                var wtsVec = MemoryMarshal.Cast<float, Vector256<float>>(wts);
                var dtsVec = MemoryMarshal.Cast<float, Vector256<float>>(dts);
                var graVec = MemoryMarshal.Cast<float, Vector256<float>>(outputGradients);

                var sumVec = Vector256<float>.Zero;

                for (int v = 0; v < graVec.Length; v++) // SIMD, partial gradient and delta
                {
                    var outGraVec = graVec[v];
                    sumVec = wtsVec[v] * outGraVec + sumVec;
                    dtsVec[v] = n * outGraVec + dtsVec[v];
                }

                // changed float result with Vector.Sum() vs. regular approach
                var sum = Vector256.Sum(sumVec);

                for (int r = graVec.Length * Vector256<float>.Count; r < wts.Length; r++)
                {
                    var outGraSpan = outputGradients[r];
                    sum = wts[r] * outGraSpan + sum;
                    dts[r] = n * outGraSpan + dts[r];
                }
                inputGradients[l] = sum;
            }
        }
    }
    // TESTING
    static (float acc, float time) RunTest(bool multiCore, float[] testData, byte[] testLabel, Net NN, int len)
    {
        bool[] c = new bool[len]; // for proper parallel count and other stuff

        Stopwatch stopwatch = Stopwatch.StartNew();

        if (multiCore)
            Parallel.For(0, len, x =>
            {
                c[x] = Test(testData.AsSpan().Slice(x * 784, 784), testLabel[x], NN);
            });
        else // single core
            for (int x = 0; x < len; x++)
                c[x] = Test(testData.AsSpan().Slice(x * 784, 784), testLabel[x], NN);

        stopwatch.Stop();

        float acc = (float)c.Count(n => n) / len * 100.0f;

        return (acc, (float)(stopwatch.Elapsed.TotalMilliseconds / 1000.0));
    }
    static bool Test(ReadOnlySpan<float> sample, byte target, Net NN)
    {
        Span<float> neurons = stackalloc float[NN.neuronLen];
        sample.CopyTo(neurons);
        FeedForward(NN.net, NN.weights, neurons);
        return target == Argmax(neurons.Slice(neurons.Length - NN.net[^1], NN.net[^1]));
    }

    static int Argmax(Span<float> neurons)
    {
        int id = 0;
        float max = neurons[0];
        for (int i = 1; i < neurons.Length; i++)
        {
            float n = neurons[i];
            if (n > max) { max = n; id = i; }
        }
        return id; // prediction
    }

    // [MethodImpl(MethodImplOptions.NoInlining)]
    // [MethodImpl(MethodImplOptions.NoInlining)]
    static void FeedForward//Unroll40
        (ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {
            var outLocal = neurons.Slice(k, net[i + 1]);
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 
            int outLocalLength = outLocal.Length;

            int l;
            for (l = 0; l < inpLocal.Length - 3; l += 4, w = 4 * outLocalLength + w)
            {
                float inpNeuron1 = inpLocal[l];
                float inpNeuron2 = inpLocal[l + 1];
                float inpNeuron3 = inpLocal[l + 2];
                float inpNeuron4 = inpLocal[l + 3];

                if (inpNeuron1 > 0)
                {
                    var inVec1 = Vector512.Create(inpNeuron1);
                    var wts1 = weights.Slice(w, outLocalLength);
                    var wtsVec1 = MemoryMarshal.Cast<float, Vector512<float>>(wts1);
                    var outVec1 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec1.Length; v++) // SIMD
                        outVec1[v] = wtsVec1[v] * inVec1 + outVec1[v];

                    for (int r = wtsVec1.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts1[r] * inpNeuron1 + outLocal[r];
                }

                if (inpNeuron2 > 0)
                {
                    var inVec2 = Vector512.Create(inpNeuron2);
                    var wts2 = weights.Slice(w + outLocalLength, outLocalLength);
                    var wtsVec2 = MemoryMarshal.Cast<float, Vector512<float>>(wts2);
                    var outVec2 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec2.Length; v++) // SIMD
                        outVec2[v] = wtsVec2[v] * inVec2 + outVec2[v];

                    for (int r = wtsVec2.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts2[r] * inpNeuron2 + outLocal[r];
                }

                if (inpNeuron3 > 0)
                {
                    var inVec3 = Vector512.Create(inpNeuron3);
                    var wts3 = weights.Slice(w + 2 * outLocalLength, outLocalLength);
                    var wtsVec3 = MemoryMarshal.Cast<float, Vector512<float>>(wts3);
                    var outVec3 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec3.Length; v++) // SIMD
                        outVec3[v] = wtsVec3[v] * inVec3 + outVec3[v];

                    for (int r = wtsVec3.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts3[r] * inpNeuron3 + outLocal[r];
                }

                if (inpNeuron4 > 0)
                {
                    var inVec4 = Vector512.Create(inpNeuron4);
                    var wts4 = weights.Slice(w + 3 * outLocalLength, outLocalLength);
                    var wtsVec4 = MemoryMarshal.Cast<float, Vector512<float>>(wts4);
                    var outVec4 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec4.Length; v++) // SIMD
                        outVec4[v] = wtsVec4[v] * inVec4 + outVec4[v];

                    for (int r = wtsVec4.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts4[r] * inpNeuron4 + outLocal[r];
                }
            }

            // Handle any remaining elements in a separate loop
            for (; l < inpLocal.Length; l++, w = outLocalLength + w)
            {
                float inpNeuron = inpLocal[l];

                if (inpNeuron <= 0)
                    continue;

                var inVec = Vector512.Create(inpNeuron);
                var wts = weights.Slice(w, outLocalLength);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts);
                var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                for (int v = 0; v < wtsVec.Length; v++) // SIMD
                    outVec[v] = wtsVec[v] * inVec + outVec[v];

                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }

    static void FeedForwardBatchProcess
        (ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {

        for (int i = 0, k = net[0], w = 0; i < net.Length - 1; i++)
        {
            var outLocal = neurons.Slice(k, net[i + 1]);
            var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k += outLocal.Length; // stack output id 
            int outLocalLength = outLocal.Length;

            int l;
            int batchSize = 4; // Process 3 input neurons at a time
            for (l = 0; l < inpLocal.Length - batchSize + 1; l += batchSize, w = batchSize * outLocalLength + w)
            {
                float inpNeuron1 = inpLocal[l];
                float inpNeuron2 = inpLocal[l + 1];
                float inpNeuron3 = inpLocal[l + 2];
                float inpNeuron4 = inpLocal[l + 3];
                if (inpNeuron1 > 0)
                    ProcessNeuron(outVec, inpNeuron1, outLocal, weights.Slice(w, outLocalLength));
                if (inpNeuron2 > 0)
                    ProcessNeuron(outVec, inpNeuron2, outLocal, weights.Slice(w + outLocalLength, outLocalLength));
                if (inpNeuron3 > 0)
                    ProcessNeuron(outVec, inpNeuron3, outLocal, weights.Slice(w + 2 * outLocalLength, outLocalLength));
                if (inpNeuron4 > 0)
                    ProcessNeuron(outVec, inpNeuron4, outLocal, weights.Slice(w + 3 * outLocalLength, outLocalLength));
            }

            // Handle any remaining elements in a separate loop
            for (; l < inpLocal.Length; l++, w = outLocalLength + w)
            {
                float inpNeuron = inpLocal[l];
                if (inpNeuron <= 0) continue;
                ProcessNeuron(outVec, inpNeuron, outLocal, weights.Slice(w, outLocalLength));
            }
        }
        static void ProcessNeuron(Span<Vector512<float>> outVec, float inpNeuron, Span<float> outLocal, ReadOnlySpan<float> wts)
        {
            var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts);

            for (int v = 0; v < wtsVec.Length; v++) // SIMD
                outVec[v] = wtsVec[v] * inpNeuron + outVec[v];

            // Default loop (no bounds checking) for the remaining elements
            for (int r = wtsVec.Length * Vector512<float>.Count; r < wts.Length; r++)
                outLocal[r] = wts[r] * inpNeuron + outLocal[r];
        }

        static void ProcessNeuron3(Span<Vector512<float>> outVec, float inpNeuron, Span<float> outLocal, ReadOnlySpan<float> wts)
        {
            //var inVec = Vector512.Create(inpNeuron);
            var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts);

            for (int v = 0; v < wtsVec.Length; v++) // SIMD
                outVec[v] = wtsVec[v] * inpNeuron + outVec[v];

            for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocal.Length; r++) // default no bounds
                outLocal[r] = wts[r] * inpNeuron + outLocal[r];
        }
    }



    static void FeedForwardGood
        (ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {
            var outLocal = neurons.Slice(k, net[i + 1]);
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 
            int outLocalLength = outLocal.Length;

            int l;
            for (l = 0; l < inpLocal.Length - 2; l += 3, w = 3 * outLocalLength + w)
            {
                float inpNeuron1 = inpLocal[l];
                float inpNeuron2 = inpLocal[l + 1];
                float inpNeuron3 = inpLocal[l + 2];

                if (inpNeuron1 > 0)
                {
                    var inVec1 = Vector512.Create(inpNeuron1);
                    var wts1 = weights.Slice(w, outLocalLength);
                    var wtsVec1 = MemoryMarshal.Cast<float, Vector512<float>>(wts1);
                    var outVec1 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec1.Length; v++) // SIMD
                        outVec1[v] = wtsVec1[v] * inVec1 + outVec1[v];

                    for (int r = wtsVec1.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts1[r] * inpNeuron1 + outLocal[r];
                }

                if (inpNeuron2 > 0)
                {
                    var inVec2 = Vector512.Create(inpNeuron2);
                    var wts2 = weights.Slice(w + outLocalLength, outLocalLength);
                    var wtsVec2 = MemoryMarshal.Cast<float, Vector512<float>>(wts2);
                    var outVec2 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec2.Length; v++) // SIMD
                        outVec2[v] = wtsVec2[v] * inVec2 + outVec2[v];

                    for (int r = wtsVec2.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts2[r] * inpNeuron2 + outLocal[r];
                }

                if (inpNeuron3 > 0)
                {
                    var inVec3 = Vector512.Create(inpNeuron3);
                    var wts3 = weights.Slice(w + 2 * outLocalLength, outLocalLength);
                    var wtsVec3 = MemoryMarshal.Cast<float, Vector512<float>>(wts3);
                    var outVec3 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec3.Length; v++) // SIMD
                        outVec3[v] = wtsVec3[v] * inVec3 + outVec3[v];

                    for (int r = wtsVec3.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts3[r] * inpNeuron3 + outLocal[r];
                }
            }

            // Handle any remaining elements in a separate loop
            for (; l < inpLocal.Length; l++, w = outLocalLength + w)
            {
                float inpNeuron = inpLocal[l];

                if (inpNeuron <= 0)
                    continue;

                var inVec = Vector512.Create(inpNeuron);
                var wts = weights.Slice(w, outLocalLength);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts);
                var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                for (int v = 0; v < wtsVec.Length; v++) // SIMD
                    outVec[v] = wtsVec[v] * inVec + outVec[v];

                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }
    static void FeedForwardUnroll3(ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {
            var outLocal = neurons.Slice(k, net[i + 1]);
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 
            int outLocalLength = outLocal.Length;

            int l;
            for (l = 0; l < inpLocal.Length - 2; l += 3, w = 3 * outLocalLength + w)
            {
                float inpNeuron1 = inpLocal[l];
                float inpNeuron2 = inpLocal[l + 1];
                float inpNeuron3 = inpLocal[l + 2];

                if (inpNeuron1 > 0)
                {
                    var inVec1 = Vector512.Create(inpNeuron1);
                    var wts1 = weights.Slice(w, outLocalLength);
                    var wtsVec1 = MemoryMarshal.Cast<float, Vector512<float>>(wts1);
                    var outVec1 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec1.Length; v++) // SIMD
                        outVec1[v] = wtsVec1[v] * inVec1 + outVec1[v];

                    for (int r = wtsVec1.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts1[r] * inpNeuron1 + outLocal[r];
                }

                if (inpNeuron2 > 0)
                {
                    var inVec2 = Vector512.Create(inpNeuron2);
                    var wts2 = weights.Slice(w + outLocalLength, outLocalLength);
                    var wtsVec2 = MemoryMarshal.Cast<float, Vector512<float>>(wts2);
                    var outVec2 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec2.Length; v++) // SIMD
                        outVec2[v] = wtsVec2[v] * inVec2 + outVec2[v];

                    for (int r = wtsVec2.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts2[r] * inpNeuron2 + outLocal[r];
                }

                if (inpNeuron3 > 0)
                {
                    var inVec3 = Vector512.Create(inpNeuron3);
                    var wts3 = weights.Slice(w + 2 * outLocalLength, outLocalLength);
                    var wtsVec3 = MemoryMarshal.Cast<float, Vector512<float>>(wts3);
                    var outVec3 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec3.Length; v++) // SIMD
                        outVec3[v] = wtsVec3[v] * inVec3 + outVec3[v];

                    for (int r = wtsVec3.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts3[r] * inpNeuron3 + outLocal[r];
                }
            }

            // Handle any remaining elements in a separate loop
            for (; l < inpLocal.Length; l++, w = outLocalLength + w)
            {
                float inpNeuron = inpLocal[l];

                if (inpNeuron <= 0)
                    continue;

                var inVec = Vector512.Create(inpNeuron);
                var wts = weights.Slice(w, outLocalLength);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts);
                var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                for (int v = 0; v < wtsVec.Length; v++) // SIMD
                    outVec[v] = wtsVec[v] * inVec + outVec[v];

                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }
    static void FeedForwardUnroll4(ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {
            var outLocal = neurons.Slice(k, net[i + 1]);
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 
            int outLocalLength = outLocal.Length;

            int l;
            for (l = 0; l < inpLocal.Length - 3; l += 4, w = 4 * outLocalLength + w)
            {
                float inpNeuron1 = inpLocal[l];
                float inpNeuron2 = inpLocal[l + 1];
                float inpNeuron3 = inpLocal[l + 2];
                float inpNeuron4 = inpLocal[l + 3];

                if (inpNeuron1 > 0)
                {
                    var inVec1 = Vector512.Create(inpNeuron1);
                    var wts1 = weights.Slice(w, outLocalLength);
                    var wtsVec1 = MemoryMarshal.Cast<float, Vector512<float>>(wts1);
                    var outVec1 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec1.Length; v++) // SIMD
                        outVec1[v] = wtsVec1[v] * inVec1 + outVec1[v];

                    for (int r = wtsVec1.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts1[r] * inpNeuron1 + outLocal[r];
                }

                if (inpNeuron2 > 0)
                {
                    var inVec2 = Vector512.Create(inpNeuron2);
                    var wts2 = weights.Slice(w + outLocalLength, outLocalLength);
                    var wtsVec2 = MemoryMarshal.Cast<float, Vector512<float>>(wts2);
                    var outVec2 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec2.Length; v++) // SIMD
                        outVec2[v] = wtsVec2[v] * inVec2 + outVec2[v];

                    for (int r = wtsVec2.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts2[r] * inpNeuron2 + outLocal[r];
                }

                if (inpNeuron3 > 0)
                {
                    var inVec3 = Vector512.Create(inpNeuron3);
                    var wts3 = weights.Slice(w + 2 * outLocalLength, outLocalLength);
                    var wtsVec3 = MemoryMarshal.Cast<float, Vector512<float>>(wts3);
                    var outVec3 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec3.Length; v++) // SIMD
                        outVec3[v] = wtsVec3[v] * inVec3 + outVec3[v];

                    for (int r = wtsVec3.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts3[r] * inpNeuron3 + outLocal[r];
                }

                if (inpNeuron4 > 0)
                {
                    var inVec4 = Vector512.Create(inpNeuron4);
                    var wts4 = weights.Slice(w + 3 * outLocalLength, outLocalLength);
                    var wtsVec4 = MemoryMarshal.Cast<float, Vector512<float>>(wts4);
                    var outVec4 = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                    for (int v = 0; v < wtsVec4.Length; v++) // SIMD
                        outVec4[v] = wtsVec4[v] * inVec4 + outVec4[v];

                    for (int r = wtsVec4.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                        outLocal[r] = wts4[r] * inpNeuron4 + outLocal[r];
                }
            }

            // Handle any remaining elements in a separate loop
            for (; l < inpLocal.Length; l++, w = outLocalLength + w)
            {
                float inpNeuron = inpLocal[l];

                if (inpNeuron <= 0)
                    continue;

                var inVec = Vector512.Create(inpNeuron);
                var wts = weights.Slice(w, outLocalLength);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts);
                var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal);

                for (int v = 0; v < wtsVec.Length; v++) // SIMD
                    outVec[v] = wtsVec[v] * inVec + outVec[v];

                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocalLength; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }

    static void FeedForwarddeff(ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {
            var outLocal = neurons.Slice(k, net[i + 1]);
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 
            for (int l = 0; l < inpLocal.Length; l++, w = outLocal.Length + w)
            {
                float inpNeuron = inpLocal[l]; // fast temporary input neuron
                if (inpNeuron <= 0) continue; // ReLU input pre-activation
                var inVec = Vector512.Create(inpNeuron);

                var wts = weights.Slice(w, outLocal.Length);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts); // span to vector reference
                var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal); // span to vector reference
                for (int v = 0; v < wtsVec.Length; v++) // SIMD
                    outVec[v] = Vector512.Multiply(wtsVec[v], inVec) + outVec[v]; //wtsVec[v] * inVec + outVec[v];
                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocal.Length; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }

    static void FeedForward3(ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        var outVec = MemoryMarshal.Cast<float, Vector512<float>>(default);
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {

            var outLocal = neurons.Slice(k, net[i + 1]);
            outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal); // span to vector reference
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 


            for (int l = 0; l < inpLocal.Length; l++, w = outLocal.Length + w)
            {
                float inpNeuron = inpLocal[l]; // fast temporary input neuron
                if (inpNeuron <= 0) continue; // ReLU input pre-activation
                var inVec = Vector512.Create(inpNeuron);

                var wts = weights.Slice(w, outLocal.Length);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts); // span to vector reference

                for (int v = 0; v < outVec.Length; v++) // SIMD
                    outVec[v] = wtsVec[v] * inVec + outVec[v];
                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocal.Length; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }
    static void FeedForwardOK(ReadOnlySpan<int> net, ReadOnlySpan<float> weights, Span<float> neurons)
    {
        for (int k = net[0], w = 0, i = 0; i < net.Length - 1; i++)
        {
        
            var outLocal = neurons.Slice(k, net[i + 1]);
            var outVec = MemoryMarshal.Cast<float, Vector512<float>>(outLocal); // span to vector reference
            var inpLocal = neurons.Slice(k - net[i], net[i]);
            k = outLocal.Length + k; // stack output id 


            for (int l = 0; l < inpLocal.Length; l++, w = outLocal.Length + w)
            {
                float inpNeuron = inpLocal[l]; // fast temporary input neuron
                if (inpNeuron <= 0) continue; // ReLU input pre-activation
                var inVec = Vector512.Create(inpNeuron);

                var wts = weights.Slice(w, outLocal.Length);
                var wtsVec = MemoryMarshal.Cast<float, Vector512<float>>(wts); // span to vector reference
                                                                                   
                for (int v = 0; v < outVec.Length; v++) // SIMD
                    outVec[v] = wtsVec[v] * inVec + outVec[v];
                for (int r = wtsVec.Length * Vector512<float>.Count; r < outLocal.Length; r++) // default no bounds
                    outLocal[r] = wts[r] * inpNeuron + outLocal[r];
            }
        }
    }

    void SetMaxMin()
    {
        minVal = new float[features];
        maxVal = new float[features];
        featureState = new bool[features];
        for (int featureIndex = 0; featureIndex < features; featureIndex++)
        {
            float currentMin = float.MaxValue, currentMax = float.MinValue;
            for (int dataIndex = 0; dataIndex < dataLength; dataIndex++)
            {
                if (!isOut[dataIndex])
                {
                    var value = trainData[featureIndex + features * dataIndex];
                    if (value < currentMin) currentMin = value;
                    if (value > currentMax) currentMax = value;
                }

            }

            featureState[featureIndex] = (currentMin != currentMax) ? true : false;

            minVal[featureIndex] = currentMin;
            maxVal[featureIndex] = currentMax;
        }
    }

    // helper
    static void Rect(ref DrawingContext dc, Brush rgb, int x, int y, int width, int height) => dc.DrawRectangle(rgb, null, new Rect(x, y, width, height));
    static void Line(ref DrawingContext dc, Pen pen, double xl, double yl, double xr, double yr) => dc.DrawLine(pen, new Point(xl, yl), new Point(xr, yr));
    void Text(ref DrawingContext dc, string str, int size, Brush rgb, int x, int y) =>
        dc.DrawText(new FormattedText(str, System.Globalization.CultureInfo.GetCultureInfo("en-us"), FlowDirection.LeftToRight, tf, size, rgb, VisualTreeHelper.GetDpi(this).PixelsPerDip), new Point(x, y));
    void SetWindow()
    {
        fs = (float)(((Canvas)this.Content).RenderSize.Width - xs * 2 - 5) / features;
        height = (int)((Canvas)this.Content).RenderSize.Height - 100 - ys;
    }
    static DrawingContext ContextHelpMod(bool isInit, ref Canvas cTmp)
    {
        if (!isInit) cTmp.Children.Clear();
        DrawingVisualElement drawingVisual = new();
        cTmp.Children.Add(drawingVisual);
        return drawingVisual.drawingVisual.RenderOpen();
    }
    static Brush[] InitColors(int clrRange)
    {
        Brush[] clrarr = new Brush[clrRange];

        byte minR = 44;
        byte minG = 23;
        byte minB = 239;
        byte maxR = 239;
        byte maxG = 185;
        byte maxB = 1;

        for (int i = 0; i < clrRange; i++)
        {
            float gradientFactor = i / (float)(clrRange - 1);
            byte r = InterpolateGradient(minR, maxR, gradientFactor);
            byte g = InterpolateGradient(minG, maxG, gradientFactor);
            byte b = InterpolateGradient(minB, maxB, gradientFactor);
            clrarr[i] = new SolidColorBrush(Color.FromRgb(r, g, b));
        }

        return clrarr;

        static byte InterpolateGradient(byte minValue, byte maxValue, double boostFactor)
        {
            double interpolatedValue = boostFactor * maxValue + (1 - boostFactor) * minValue;
            return (byte)Math.Ceiling(interpolatedValue);
        }
    }

    static Brush[] InitColors33(int clrRange)
    {
        Brush[] clrarr = new Brush[clrRange];

        byte minR = 44;
        byte minG = 23;
        byte minB = 239;
        byte maxR = 239;
        byte maxG = 185;
        byte maxB = 1;

        for (int i = 0; i < clrRange; i++)
        {
            float gradientFactor = i / (float)(clrRange - 1);
            byte r = InterpolateGradient(minR, maxR, gradientFactor);
            byte g = InterpolateGradient(minG, maxG, gradientFactor);
            byte b = InterpolateGradient(minB, maxB, gradientFactor);
            clrarr[i] = new SolidColorBrush(Color.FromRgb(r, g, b));
        }

        return clrarr;

        static byte InterpolateGradient(byte minValue, byte maxValue, double gradientFactor)
        {
            double interpolatedValue = (1 - gradientFactor) * minValue + gradientFactor * maxValue;
            return (byte)Math.Ceiling(interpolatedValue);
        }
    }

    static Brush[] InitColors4(int clrRange)
    {
        Brush[] clrarr = new Brush[clrRange];

        for (int i = 0; i < clrRange; i++)
        {
            byte minR = 44;
            byte minG = 23;
            byte minB = 239;
            byte maxR = 239;
            byte maxG = 185;
            byte maxB = 1;

            float boostFactor = i / (float)(clrRange - 1);
            byte r = Interpolate(minR, maxR, boostFactor);
            byte g = Interpolate(minG, maxG, boostFactor);
            byte b = Interpolate(minB, maxB, boostFactor);
            clrarr[i] = new SolidColorBrush(Color.FromRgb(r, g, b));
        }
        return clrarr;

        static byte Interpolate(byte minValue, byte maxValue, double boostFactor)
        {
            double interpolatedValue = boostFactor * maxValue + (1 - boostFactor) * minValue;
            // return (byte)Math.Round(Math.Clamp(interpolatedValue, 0, 255));
            // return (byte)Math.Round(interpolatedValue);
            return (byte)Math.Ceiling(interpolatedValue);
        }
    }

    static Brush RGB(byte red, byte green, byte blue)
    {
        Brush brush = new SolidColorBrush(Color.FromRgb(red, green, blue));
        brush.Freeze();
        return brush;
    }
} // TheWindow end

/*
[System.Runtime.CompilerServices.InlineArray(784)]
public ref struct Sample
{
    public Span<float> s;
}
*/

struct Rules
{
    public double max { get; set; }
    public double min { get; set; }
    public int feature { get; set; }
    public int label { get; set; }
}
struct Ranges
{
    public (float min, float max) minMax { get; set; }
    public int feature { get; set; }
    public int label { get; set; }
}
struct Control
{
    public int lastPoint { get; set; }
    public int lastY { get; set; }
    public int ruleFeature { get; set; }
    public int ruleLabel { get; set; }
}
readonly struct Net
{
    public int[] net { get; }
    public float[] weights { get; }
    public int neuronLen { get; }

    public Net(int[] net, int seed)
    {
        this.neuronLen = net.Sum();
        this.net = net;
        this.weights = Glorot(this.net, new(seed));
    }

    static float[] Glorot(int[] net, Random rnd)
    {
        int len = 0;
        for (int n = 0; n < net.Length - 1; n++)
            len += net[n] * net[n + 1];

        float[] weights = new float[len];

        for (int i = 0, w = 0; i < net.Length - 1; i++, w += net[i - 0] * net[i - 1]) // layer
        {
            float sd = MathF.Sqrt(6.0f / (net[i] + net[i + 1]));
            for (int m = w; m < w + net[i] * net[i + 1]; m++) // weights
                weights[m] = (float)rnd.NextDouble() * sd * 2 - sd;
        }
        return weights;
    }
}

readonly struct AutoData
{
    public readonly byte[] LabelsTraining { get; }
    public readonly byte[] labelsTest { get; }
    public readonly float[] samplesTrainingF { get; }
    public readonly float[] samplesTestF { get; }

    static float[] NormalizeData(byte[] samples)
    {
        float[] samplesF = new float[samples.Length];
        for (int i = 0; i < samples.Length; i++)
            samplesF[i] = samples[i] / 255f;
        return samplesF;
    }

    public AutoData(string yourPath, DatasetType datasetType)
    {

        byte[] test, training;

        // Define URLs and file paths based on the dataset type
        string trainDataUrl, trainLabelUrl, testDataUrl, testLabelUrl;
        string trainDataPath, trainLabelPath, testDataPath, testLabelPath;

        if (datasetType == DatasetType.MNIST)
        {
            // Hardcoded URLs from my GitHub
            trainDataUrl = "https://github.com/grensen/gif_test/raw/master/MNIST_Data/train-images.idx3-ubyte";
            trainLabelUrl = "https://github.com/grensen/gif_test/raw/master/MNIST_Data/train-labels.idx1-ubyte";
            testDataUrl = "https://github.com/grensen/gif_test/raw/master/MNIST_Data/t10k-images.idx3-ubyte";
            testLabelUrl = "https://github.com/grensen/gif_test/raw/master/MNIST_Data/t10k-labels.idx1-ubyte";

            trainDataPath = "trainData_MNIST";
            trainLabelPath = "trainLabel_MNIST";
            testDataPath = "testData_MNIST";
            testLabelPath = "testLabel_MNIST";
        }
        else // if (datasetType == DatasetType.FashionMNIST)
        {
            trainDataUrl = "https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/train-images-idx3-ubyte.gz";
            trainLabelUrl = "https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/train-labels-idx1-ubyte.gz";
            testDataUrl = "https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/t10k-images-idx3-ubyte.gz";
            testLabelUrl = "https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/t10k-labels-idx1-ubyte.gz";

            trainDataPath = "trainData_FashionMNIST";
            trainLabelPath = "trainLabel_FashionMNIST";
            testDataPath = "testData_FashionMNIST";
            testLabelPath = "testLabel_FashionMNIST";
        }

        if (!File.Exists(System.IO.Path.Combine(yourPath, trainDataPath))
            || !File.Exists(System.IO.Path.Combine(yourPath, trainLabelPath))
            || !File.Exists(System.IO.Path.Combine(yourPath, testDataPath))
            || !File.Exists(System.IO.Path.Combine(yourPath, testLabelPath)))
        {
            Console.WriteLine($"Status: {datasetType} Dataset Not found");
            if (!Directory.Exists(yourPath)) Directory.CreateDirectory(yourPath);

            // Padding bits: data = 16, labels = 8
            Console.WriteLine("Action: Downloading and Cleaning the Dataset from GitHub");
            training = DownloadAndExtract(trainDataUrl, datasetType).Skip(16).Take(60000 * 784).ToArray();
            LabelsTraining = DownloadAndExtract(trainLabelUrl, datasetType).Skip(8).Take(60000).ToArray();
            test = DownloadAndExtract(testDataUrl, datasetType).Skip(16).Take(10000 * 784).ToArray();
            labelsTest = DownloadAndExtract(testLabelUrl, datasetType).Skip(8).Take(10000).ToArray();

            Console.WriteLine("Save Path: " + yourPath + "\n");
            File.WriteAllBytesAsync(System.IO.Path.Combine(yourPath, trainDataPath), training);
            File.WriteAllBytesAsync(System.IO.Path.Combine(yourPath, trainLabelPath), LabelsTraining);
            File.WriteAllBytesAsync(System.IO.Path.Combine(yourPath, testDataPath), test);
            File.WriteAllBytesAsync(System.IO.Path.Combine(yourPath, testLabelPath), labelsTest);
        }
        else
        {
            // Data exists on the system, just load from yourPath
            Console.WriteLine($"Dataset: {datasetType} ({yourPath})" + "\n");
            training = File.ReadAllBytes(System.IO.Path.Combine(yourPath, trainDataPath)).Take(60000 * 784).ToArray();
            LabelsTraining = File.ReadAllBytes(System.IO.Path.Combine(yourPath, trainLabelPath)).Take(60000).ToArray();
            test = File.ReadAllBytes(System.IO.Path.Combine(yourPath, testDataPath)).Take(10000 * 784).ToArray();
            labelsTest = File.ReadAllBytes(System.IO.Path.Combine(yourPath, testLabelPath)).Take(10000).ToArray();
        }

        samplesTrainingF = NormalizeData(training);
        samplesTestF = NormalizeData(test);
    }

    static byte[] DownloadAndExtract(string url, DatasetType datasetType)
    {
        using var client = new HttpClient();
        using var responseStream = client.GetStreamAsync(url).Result;
        using var ms = new MemoryStream();
        if (datasetType == DatasetType.FashionMNIST)
        {
            using var gzipStream = new GZipStream(responseStream, CompressionMode.Decompress);
            gzipStream.CopyTo(ms);
        }
        else
        {
            responseStream.CopyTo(ms);
        }

        return ms.ToArray();
    }

    public enum DatasetType
    {
        MNIST,
        FashionMNIST
    }
}
class RunningStat
{
    private int count;
    private float mean, sumSquaredDifferences;

    public void Add(float newValue)
    {
        count++;

        float delta = newValue - mean;
        mean += delta / count;
        float deltaSquared = newValue - mean;
        sumSquaredDifferences += delta * deltaSquared;
    }

    public float Mean() => count > 0 ? mean : 0.0f;

    public float Variance() => count > 1 ? sumSquaredDifferences / count : 0.0f;

    public float StandardDeviation() => MathF.Sqrt(Variance());
}

class DrawingVisualElement : FrameworkElement
{
    private readonly VisualCollection _children;
    public DrawingVisual drawingVisual;
    public DrawingVisualElement()
    {
        _children = new VisualCollection(this);
        drawingVisual = new DrawingVisual();
        _children.Add(drawingVisual);
    }
    public void ClearVisualElement() => _children.Clear();
    protected override int VisualChildrenCount => _children.Count;
    protected override Visual GetVisualChild(int index) => _children[index];
}
